/* tslint:disable */
/* eslint-disable */
/**
 * Endo4Life APIs
 * AI-integrated e-Learning platform for endometriosis education
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CommentCriteria
 */
export interface CommentCriteria {
    /**
     * 
     * @type {string}
     * @memberof CommentCriteria
     */
    'resourceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentCriteria
     */
    'courseId'?: string;
}
/**
 * 
 * @export
 * @interface CommentResponseDto
 */
export interface CommentResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CommentResponseDto
     */
    'id'?: string;
    /**
     * Comment content
     * @type {string}
     * @memberof CommentResponseDto
     */
    'content'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CommentResponseDto
     */
    'attachments'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CommentResponseDto
     */
    'createdBy'?: string;
    /**
     * 
     * @type {UserInfoDto}
     * @memberof CommentResponseDto
     */
    'createdByInfo'?: UserInfoDto;
    /**
     * 
     * @type {string}
     * @memberof CommentResponseDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {Array<CommentResponseDto>}
     * @memberof CommentResponseDto
     */
    'replies'?: Array<CommentResponseDto>;
}
/**
 * 
 * @export
 * @interface CommentResponsePaginatedDto
 */
export interface CommentResponsePaginatedDto {
    /**
     * 
     * @type {Array<CommentResponseDto>}
     * @memberof CommentResponsePaginatedDto
     */
    'data'?: Array<CommentResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof CommentResponsePaginatedDto
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface CourseCriteria
 */
export interface CourseCriteria {
    /**
     * 
     * @type {string}
     * @memberof CourseCriteria
     */
    'title'?: string;
    /**
     * 
     * @type {CourseState}
     * @memberof CourseCriteria
     */
    'state'?: CourseState;
}


/**
 * 
 * @export
 * @interface CourseDetailResponseDto
 */
export interface CourseDetailResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CourseDetailResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseDetailResponseDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseDetailResponseDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseDetailResponseDto
     */
    'lecturer'?: string;
    /**
     * 
     * @type {CourseState}
     * @memberof CourseDetailResponseDto
     */
    'state'?: CourseState;
    /**
     * 
     * @type {number}
     * @memberof CourseDetailResponseDto
     */
    'rating'?: number;
    /**
     * 
     * @type {number}
     * @memberof CourseDetailResponseDto
     */
    'registrationNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof CourseDetailResponseDto
     */
    'viewNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof CourseDetailResponseDto
     */
    'thumbnail'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseDetailResponseDto
     */
    'thumbnailUrl'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CourseDetailResponseDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CourseDetailResponseDto
     */
    'tagsDetail'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CourseDetailResponseDto
     */
    'totalCourseSection'?: number;
    /**
     * 
     * @type {string}
     * @memberof CourseDetailResponseDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseDetailResponseDto
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {Array<CourseSectionResponseDto>}
     * @memberof CourseDetailResponseDto
     */
    'courseSections'?: Array<CourseSectionResponseDto>;
}


/**
 * 
 * @export
 * @interface CourseResponseDto
 */
export interface CourseResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CourseResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseResponseDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseResponseDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseResponseDto
     */
    'lecturer'?: string;
    /**
     * 
     * @type {CourseState}
     * @memberof CourseResponseDto
     */
    'state'?: CourseState;
    /**
     * 
     * @type {number}
     * @memberof CourseResponseDto
     */
    'rating'?: number;
    /**
     * 
     * @type {number}
     * @memberof CourseResponseDto
     */
    'registrationNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof CourseResponseDto
     */
    'viewNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof CourseResponseDto
     */
    'thumbnail'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseResponseDto
     */
    'thumbnailUrl'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CourseResponseDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CourseResponseDto
     */
    'tagsDetail'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CourseResponseDto
     */
    'totalCourseSection'?: number;
    /**
     * 
     * @type {string}
     * @memberof CourseResponseDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseResponseDto
     */
    'updatedAt'?: string;
}


/**
 * 
 * @export
 * @interface CourseResponsePaginatedDto
 */
export interface CourseResponsePaginatedDto {
    /**
     * 
     * @type {Array<CourseResponseDto>}
     * @memberof CourseResponsePaginatedDto
     */
    'data'?: Array<CourseResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof CourseResponsePaginatedDto
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface CourseSectionCriteria
 */
export interface CourseSectionCriteria {
    /**
     * 
     * @type {string}
     * @memberof CourseSectionCriteria
     */
    'courseId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseSectionCriteria
     */
    'title'?: string;
    /**
     * 
     * @type {CourseState}
     * @memberof CourseSectionCriteria
     */
    'state'?: CourseState;
}


/**
 * 
 * @export
 * @interface CourseSectionResponseDto
 */
export interface CourseSectionResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CourseSectionResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseSectionResponseDto
     */
    'title'?: string;
    /**
     * 
     * @type {CourseState}
     * @memberof CourseSectionResponseDto
     */
    'state'?: CourseState;
    /**
     * 
     * @type {string}
     * @memberof CourseSectionResponseDto
     */
    'thumbnailUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseSectionResponseDto
     */
    'attachments'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseSectionResponseDto
     */
    'lastUpdated'?: string;
}


/**
 * 
 * @export
 * @interface CourseSectionResponsePaginatedDto
 */
export interface CourseSectionResponsePaginatedDto {
    /**
     * 
     * @type {Array<CourseSectionResponseDto>}
     * @memberof CourseSectionResponsePaginatedDto
     */
    'data'?: Array<CourseSectionResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof CourseSectionResponsePaginatedDto
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CourseState = {
    Draft: 'DRAFT',
    Public: 'PUBLIC',
    Private: 'PRIVATE',
    Archived: 'ARCHIVED'
} as const;

export type CourseState = typeof CourseState[keyof typeof CourseState];


/**
 * 
 * @export
 * @interface CreateCommentRequestDto
 */
export interface CreateCommentRequestDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCommentRequestDto
     */
    'attachments'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateCommentRequestDto
     */
    'resourceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCommentRequestDto
     */
    'courseId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCommentRequestDto
     */
    'parentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCommentRequestDto
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCommentRequestDto
     */
    'userInfoId': string;
}
/**
 * 
 * @export
 * @interface CreateCourseRequestDto
 */
export interface CreateCourseRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateCourseRequestDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseRequestDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseRequestDto
     */
    'lecturer'?: string;
    /**
     * 
     * @type {CourseState}
     * @memberof CreateCourseRequestDto
     */
    'state': CourseState;
    /**
     * MinIO object key for thumbnail (uploaded via presigned URL)
     * @type {string}
     * @memberof CreateCourseRequestDto
     */
    'thumbnail'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCourseRequestDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCourseRequestDto
     */
    'tagsDetail'?: Array<string>;
}


/**
 * 
 * @export
 * @interface CreateCourseSectionRequestDto
 */
export interface CreateCourseSectionRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateCourseSectionRequestDto
     */
    'courseId': string;
    /**
     * 
     * @type {CourseState}
     * @memberof CreateCourseSectionRequestDto
     */
    'state'?: CourseState;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseSectionRequestDto
     */
    'title'?: string;
    /**
     * 
     * @type {CreateCourseSectionRequestDtoAttribute}
     * @memberof CreateCourseSectionRequestDto
     */
    'attribute'?: CreateCourseSectionRequestDtoAttribute;
    /**
     * 
     * @type {number}
     * @memberof CreateCourseSectionRequestDto
     */
    'totalCredits'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCourseSectionRequestDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCourseSectionRequestDto
     */
    'tagsDetail'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseSectionRequestDto
     */
    'thumbnail'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseSectionRequestDto
     */
    'attachments'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateCourseSectionRequestDto
     */
    'videoDuration'?: number;
}


/**
 * 
 * @export
 * @interface CreateCourseSectionRequestDtoAttribute
 */
export interface CreateCourseSectionRequestDtoAttribute {
    /**
     * 
     * @type {MetaDataCourseSectionDto}
     * @memberof CreateCourseSectionRequestDtoAttribute
     */
    'metadata'?: MetaDataCourseSectionDto;
}
/**
 * 
 * @export
 * @interface CreateDoctorUserConversationDto
 */
export interface CreateDoctorUserConversationDto {
    /**
     * 
     * @type {DoctorUserConversationState}
     * @memberof CreateDoctorUserConversationDto
     */
    'state': DoctorUserConversationState;
    /**
     * 
     * @type {DoctorUserConversationType}
     * @memberof CreateDoctorUserConversationDto
     */
    'type': DoctorUserConversationType;
    /**
     * Resource (video/image) this conversation is about
     * @type {string}
     * @memberof CreateDoctorUserConversationDto
     */
    'resourceId': string;
    /**
     * Optional: Doctor to assign the question to
     * @type {string}
     * @memberof CreateDoctorUserConversationDto
     */
    'assigneeId'?: string;
    /**
     * Optional: Parent conversation ID for replies
     * @type {string}
     * @memberof CreateDoctorUserConversationDto
     */
    'parentId'?: string;
    /**
     * Question or answer content
     * @type {string}
     * @memberof CreateDoctorUserConversationDto
     */
    'content': string;
    /**
     * Array of MinIO object keys for attachments (uploaded via presigned URLs)
     * @type {Array<string>}
     * @memberof CreateDoctorUserConversationDto
     */
    'attachmentUrls'?: Array<string>;
}


/**
 * 
 * @export
 * @interface CreateQuestionRequestDto
 */
export interface CreateQuestionRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateQuestionRequestDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateQuestionRequestDto
     */
    'description'?: string;
    /**
     * 
     * @type {QuestionType}
     * @memberof CreateQuestionRequestDto
     */
    'type': QuestionType;
    /**
     * 
     * @type {object}
     * @memberof CreateQuestionRequestDto
     */
    'answers'?: object;
    /**
     * 
     * @type {number}
     * @memberof CreateQuestionRequestDto
     */
    'orderIndex'?: number;
    /**
     * 
     * @type {Array<QuestionAttachmentCreateDto>}
     * @memberof CreateQuestionRequestDto
     */
    'attachments'?: Array<QuestionAttachmentCreateDto>;
}


/**
 * 
 * @export
 * @interface CreateResourceRequest
 */
export interface CreateResourceRequest {
    /**
     * 
     * @type {UploadType}
     * @memberof CreateResourceRequest
     */
    'type': UploadType;
    /**
     * 
     * @type {Array<CreateResourceRequestDto>}
     * @memberof CreateResourceRequest
     */
    'metadata'?: Array<CreateResourceRequestDto>;
}


/**
 * 
 * @export
 * @interface CreateResourceRequestDto
 */
export interface CreateResourceRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateResourceRequestDto
     */
    'thumbnail'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateResourceRequestDto
     */
    'objectKey'?: string;
    /**
     * Title of the resource
     * @type {string}
     * @memberof CreateResourceRequestDto
     */
    'title'?: string;
    /**
     * Description of the resource
     * @type {string}
     * @memberof CreateResourceRequestDto
     */
    'description'?: string;
    /**
     * 
     * @type {ResourceState}
     * @memberof CreateResourceRequestDto
     */
    'state'?: ResourceState;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateResourceRequestDto
     */
    'tag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateResourceRequestDto
     */
    'detailTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateResourceRequestDto
     */
    'anatomyLocationTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateResourceRequestDto
     */
    'lightTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateResourceRequestDto
     */
    'hpTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateResourceRequestDto
     */
    'upperGastroAnatomyTag'?: Array<string>;
}


/**
 * 
 * @export
 * @interface CreateTagRequestDto
 */
export interface CreateTagRequestDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateTagRequestDto
     */
    'tag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateTagRequestDto
     */
    'detailTag'?: Array<string>;
    /**
     * 
     * @type {TagType}
     * @memberof CreateTagRequestDto
     */
    'type'?: TagType;
}


/**
 * 
 * @export
 * @interface CreateTestRequestDto
 */
export interface CreateTestRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTestRequestDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTestRequestDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTestRequestDto
     */
    'courseId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTestRequestDto
     */
    'courseSectionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTestRequestDto
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTestRequestDto
     */
    'state'?: string;
    /**
     * 
     * @type {Array<CreateQuestionRequestDto>}
     * @memberof CreateTestRequestDto
     */
    'questions'?: Array<CreateQuestionRequestDto>;
}
/**
 * 
 * @export
 * @interface CreateUserRequestDto
 */
export interface CreateUserRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequestDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequestDto
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequestDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequestDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequestDto
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {UserInfoRole}
     * @memberof CreateUserRequestDto
     */
    'role': UserInfoRole;
    /**
     * 
     * @type {UserInfoState}
     * @memberof CreateUserRequestDto
     */
    'state'?: UserInfoState;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequestDto
     */
    'password': string;
    /**
     * MinIO object key for avatar (uploaded via presigned URL)
     * @type {string}
     * @memberof CreateUserRequestDto
     */
    'avatar'?: string;
    /**
     * List of certificate object keys (uploaded via presigned URL)
     * @type {Array<string>}
     * @memberof CreateUserRequestDto
     */
    'certificates'?: Array<string>;
}


/**
 * 
 * @export
 * @interface DoctorUserConversationCriteria
 */
export interface DoctorUserConversationCriteria {
    /**
     * Filter by resource ID
     * @type {string}
     * @memberof DoctorUserConversationCriteria
     */
    'resourceId'?: string;
    /**
     * Filter by questioner user ID
     * @type {string}
     * @memberof DoctorUserConversationCriteria
     */
    'questionerId'?: string;
    /**
     * Filter by assigned doctor ID
     * @type {string}
     * @memberof DoctorUserConversationCriteria
     */
    'assigneeId'?: string;
    /**
     * 
     * @type {DoctorUserConversationState}
     * @memberof DoctorUserConversationCriteria
     */
    'state'?: DoctorUserConversationState;
}


/**
 * 
 * @export
 * @interface DoctorUserConversationResponseDto
 */
export interface DoctorUserConversationResponseDto {
    /**
     * 
     * @type {string}
     * @memberof DoctorUserConversationResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {DoctorUserConversationType}
     * @memberof DoctorUserConversationResponseDto
     */
    'type'?: DoctorUserConversationType;
    /**
     * 
     * @type {DoctorUserConversationState}
     * @memberof DoctorUserConversationResponseDto
     */
    'state'?: DoctorUserConversationState;
    /**
     * Question or answer content
     * @type {string}
     * @memberof DoctorUserConversationResponseDto
     */
    'content'?: string;
    /**
     * Array of presigned URLs for attached images
     * @type {Array<string>}
     * @memberof DoctorUserConversationResponseDto
     */
    'attachmentUrls'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DoctorUserConversationResponseDto
     */
    'resourceId'?: string;
    /**
     * 
     * @type {UserInfoDto}
     * @memberof DoctorUserConversationResponseDto
     */
    'questionerInfo'?: UserInfoDto;
    /**
     * 
     * @type {UserInfoDto}
     * @memberof DoctorUserConversationResponseDto
     */
    'assigneeInfo'?: UserInfoDto;
    /**
     * Parent conversation ID for replies
     * @type {string}
     * @memberof DoctorUserConversationResponseDto
     */
    'parentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoctorUserConversationResponseDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoctorUserConversationResponseDto
     */
    'updatedAt'?: string;
    /**
     * Nested replies to this conversation
     * @type {Array<DoctorUserConversationResponseDto>}
     * @memberof DoctorUserConversationResponseDto
     */
    'replies'?: Array<DoctorUserConversationResponseDto>;
}


/**
 * 
 * @export
 * @interface DoctorUserConversationResponsePaginatedDto
 */
export interface DoctorUserConversationResponsePaginatedDto {
    /**
     * 
     * @type {Array<DoctorUserConversationResponseDto>}
     * @memberof DoctorUserConversationResponsePaginatedDto
     */
    'data'?: Array<DoctorUserConversationResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof DoctorUserConversationResponsePaginatedDto
     */
    'total'?: number;
}
/**
 * PUBLIC = visible to all users, DRAFT = not yet published
 * @export
 * @enum {string}
 */

export const DoctorUserConversationState = {
    Public: 'PUBLIC',
    Draft: 'DRAFT'
} as const;

export type DoctorUserConversationState = typeof DoctorUserConversationState[keyof typeof DoctorUserConversationState];


/**
 * Type of resource being discussed
 * @export
 * @enum {string}
 */

export const DoctorUserConversationType = {
    Video: 'VIDEO',
    Image: 'IMAGE'
} as const;

export type DoctorUserConversationType = typeof DoctorUserConversationType[keyof typeof DoctorUserConversationType];


/**
 * 
 * @export
 * @interface GeneratePreSignedUrlDto
 */
export interface GeneratePreSignedUrlDto {
    /**
     * 
     * @type {ResourceType}
     * @memberof GeneratePreSignedUrlDto
     */
    'resourceType': ResourceType;
    /**
     * 
     * @type {number}
     * @memberof GeneratePreSignedUrlDto
     */
    'numberOfUrls': number;
}


/**
 * 
 * @export
 * @interface HealthResponseDto
 */
export interface HealthResponseDto {
    /**
     * 
     * @type {string}
     * @memberof HealthResponseDto
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof HealthResponseDto
     */
    'service'?: string;
    /**
     * 
     * @type {string}
     * @memberof HealthResponseDto
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof HealthResponseDto
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface IdWrapperDto
 */
export interface IdWrapperDto {
    /**
     * 
     * @type {string}
     * @memberof IdWrapperDto
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface InviteUserRequestDto
 */
export interface InviteUserRequestDto {
    /**
     * 
     * @type {string}
     * @memberof InviteUserRequestDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof InviteUserRequestDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof InviteUserRequestDto
     */
    'lastName': string;
    /**
     * 
     * @type {UserInfoRole}
     * @memberof InviteUserRequestDto
     */
    'role': UserInfoRole;
}


/**
 * 
 * @export
 * @interface LectureAndTestDto
 */
export interface LectureAndTestDto {
    /**
     * User progress course section ID
     * @type {string}
     * @memberof LectureAndTestDto
     */
    'id'?: string;
    /**
     * Course section ID
     * @type {string}
     * @memberof LectureAndTestDto
     */
    'courseSectionId'?: string;
    /**
     * 
     * @type {CourseState}
     * @memberof LectureAndTestDto
     */
    'state'?: CourseState;
    /**
     * 
     * @type {string}
     * @memberof LectureAndTestDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof LectureAndTestDto
     */
    'attribute'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LectureAndTestDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof LectureAndTestDto
     */
    'tagsDetail'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof LectureAndTestDto
     */
    'attachmentUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof LectureAndTestDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof LectureAndTestDto
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof LectureAndTestDto
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {number}
     * @memberof LectureAndTestDto
     */
    'totalCredits'?: number;
    /**
     * 
     * @type {number}
     * @memberof LectureAndTestDto
     */
    'videoDuration'?: number;
    /**
     * 
     * @type {number}
     * @memberof LectureAndTestDto
     */
    'totalQuestionLectureReviewTest'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof LectureAndTestDto
     */
    'isCompletedVideoCourseSection'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LectureAndTestDto
     */
    'isCompletedLectureReviewQuestion'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LectureAndTestDto
     */
    'isCompletedCourseSection'?: boolean;
}


/**
 * 
 * @export
 * @interface MetaDataCourseSectionDto
 */
export interface MetaDataCourseSectionDto {
    /**
     * 
     * @type {string}
     * @memberof MetaDataCourseSectionDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetaDataCourseSectionDto
     */
    'mainContent'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetaDataCourseSectionDto
     */
    'lessonObjectives'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetaDataCourseSectionDto
     */
    'target'?: string;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    'size'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pageable
     */
    'sort'?: Array<string>;
}
/**
 * 
 * @export
 * @interface QuestionAttachmentCreateDto
 */
export interface QuestionAttachmentCreateDto {
    /**
     * MinIO object key (UUID)
     * @type {string}
     * @memberof QuestionAttachmentCreateDto
     */
    'objectKey': string;
    /**
     * MinIO bucket name
     * @type {string}
     * @memberof QuestionAttachmentCreateDto
     */
    'bucket': string;
    /**
     * 
     * @type {string}
     * @memberof QuestionAttachmentCreateDto
     */
    'fileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionAttachmentCreateDto
     */
    'fileType'?: string;
    /**
     * File size in bytes
     * @type {number}
     * @memberof QuestionAttachmentCreateDto
     */
    'fileSize'?: number;
    /**
     * Image width in pixels
     * @type {number}
     * @memberof QuestionAttachmentCreateDto
     */
    'width'?: number;
    /**
     * Image height in pixels
     * @type {number}
     * @memberof QuestionAttachmentCreateDto
     */
    'height'?: number;
}
/**
 * 
 * @export
 * @interface QuestionAttachmentResponseDto
 */
export interface QuestionAttachmentResponseDto {
    /**
     * 
     * @type {string}
     * @memberof QuestionAttachmentResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionAttachmentResponseDto
     */
    'fileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionAttachmentResponseDto
     */
    'fileType'?: string;
    /**
     * File size in bytes
     * @type {number}
     * @memberof QuestionAttachmentResponseDto
     */
    'fileSize'?: number;
    /**
     * Image width in pixels
     * @type {number}
     * @memberof QuestionAttachmentResponseDto
     */
    'width'?: number;
    /**
     * Image height in pixels
     * @type {number}
     * @memberof QuestionAttachmentResponseDto
     */
    'height'?: number;
    /**
     * Pre-signed URL to access the attachment
     * @type {string}
     * @memberof QuestionAttachmentResponseDto
     */
    'fileUrl'?: string;
}
/**
 * 
 * @export
 * @interface QuestionResponseDto
 */
export interface QuestionResponseDto {
    /**
     * 
     * @type {string}
     * @memberof QuestionResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponseDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponseDto
     */
    'description'?: string;
    /**
     * 
     * @type {QuestionType}
     * @memberof QuestionResponseDto
     */
    'type'?: QuestionType;
    /**
     * JSON structure for answers, e.g., { options: [], correctAnswer: \'\' }
     * @type {object}
     * @memberof QuestionResponseDto
     */
    'answers'?: object;
    /**
     * 
     * @type {number}
     * @memberof QuestionResponseDto
     */
    'orderIndex'?: number;
    /**
     * 
     * @type {Array<QuestionAttachmentResponseDto>}
     * @memberof QuestionResponseDto
     */
    'attachments'?: Array<QuestionAttachmentResponseDto>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const QuestionType = {
    SingleChoice: 'SINGLE_CHOICE',
    MultipleChoice: 'MULTIPLE_CHOICE',
    FillInTheBlank: 'FILL_IN_THE_BLANK',
    Essay: 'ESSAY'
} as const;

export type QuestionType = typeof QuestionType[keyof typeof QuestionType];


/**
 * 
 * @export
 * @interface RecordDataUserCourseSectionDto
 */
export interface RecordDataUserCourseSectionDto {
    /**
     * Total time in seconds
     * @type {number}
     * @memberof RecordDataUserCourseSectionDto
     */
    'totalTimeUserWatchedVideo': number;
}
/**
 * 
 * @export
 * @interface ResourceCriteria
 */
export interface ResourceCriteria {
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceCriteria
     */
    'ids'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ResourceCriteria
     */
    'title'?: string;
    /**
     * 
     * @type {ResourceType}
     * @memberof ResourceCriteria
     */
    'type'?: ResourceType;
    /**
     * 
     * @type {ResourceState}
     * @memberof ResourceCriteria
     */
    'state'?: ResourceState;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceCriteria
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ResourceCriteria
     */
    'fromDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceCriteria
     */
    'toDate'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceCriteria
     */
    'tag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceCriteria
     */
    'detailTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceCriteria
     */
    'endoscopyTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceCriteria
     */
    'lightTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceCriteria
     */
    'hpTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceCriteria
     */
    'locationUpperTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceCriteria
     */
    'searchWords'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ResourceCriteria
     */
    'commentCountTo'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceCriteria
     */
    'commentCountFrom'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceCriteria
     */
    'viewNumberTo'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceCriteria
     */
    'viewNumberFrom'?: number;
}


/**
 * 
 * @export
 * @interface ResourceDetailResponseDto
 */
export interface ResourceDetailResponseDto {
    /**
     * 
     * @type {string}
     * @memberof ResourceDetailResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceDetailResponseDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceDetailResponseDto
     */
    'description'?: string;
    /**
     * 
     * @type {ResourceType}
     * @memberof ResourceDetailResponseDto
     */
    'type'?: ResourceType;
    /**
     * 
     * @type {ResourceState}
     * @memberof ResourceDetailResponseDto
     */
    'state'?: ResourceState;
    /**
     * 
     * @type {string}
     * @memberof ResourceDetailResponseDto
     */
    'thumbnail'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceDetailResponseDto
     */
    'thumbnailUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResourceDetailResponseDto
     */
    'viewNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceDetailResponseDto
     */
    'commentCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceDetailResponseDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceDetailResponseDto
     */
    'tag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceDetailResponseDto
     */
    'detailTag'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ResourceDetailResponseDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceDetailResponseDto
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceDetailResponseDto
     */
    'resourceUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceDetailResponseDto
     */
    'dimension'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceDetailResponseDto
     */
    'size'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceDetailResponseDto
     */
    'extension'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResourceDetailResponseDto
     */
    'time'?: number;
}


/**
 * 
 * @export
 * @interface ResourceResponseDto
 */
export interface ResourceResponseDto {
    /**
     * 
     * @type {string}
     * @memberof ResourceResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceResponseDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceResponseDto
     */
    'description'?: string;
    /**
     * 
     * @type {ResourceType}
     * @memberof ResourceResponseDto
     */
    'type'?: ResourceType;
    /**
     * 
     * @type {ResourceState}
     * @memberof ResourceResponseDto
     */
    'state'?: ResourceState;
    /**
     * 
     * @type {string}
     * @memberof ResourceResponseDto
     */
    'thumbnail'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceResponseDto
     */
    'thumbnailUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResourceResponseDto
     */
    'viewNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceResponseDto
     */
    'commentCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceResponseDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceResponseDto
     */
    'tag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceResponseDto
     */
    'detailTag'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ResourceResponseDto
     */
    'createdAt'?: string;
}


/**
 * 
 * @export
 * @interface ResourceResponsePaginatedDto
 */
export interface ResourceResponsePaginatedDto {
    /**
     * 
     * @type {Array<ResourceResponseDto>}
     * @memberof ResourceResponsePaginatedDto
     */
    'data'?: Array<ResourceResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof ResourceResponsePaginatedDto
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ResourceState = {
    Draft: 'DRAFT',
    Public: 'PUBLIC',
    Private: 'PRIVATE',
    Unlisted: 'UNLISTED'
} as const;

export type ResourceState = typeof ResourceState[keyof typeof ResourceState];


/**
 * 
 * @export
 * @enum {string}
 */

export const ResourceType = {
    Image: 'IMAGE',
    Video: 'VIDEO',
    Avatar: 'AVATAR',
    Thumbnail: 'THUMBNAIL',
    Other: 'OTHER',
    Process: 'PROCESS'
} as const;

export type ResourceType = typeof ResourceType[keyof typeof ResourceType];


/**
 * 
 * @export
 * @interface ResponseDetailCourseSectionDto
 */
export interface ResponseDetailCourseSectionDto {
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseSectionDto
     */
    'id'?: string;
    /**
     * 
     * @type {CourseState}
     * @memberof ResponseDetailCourseSectionDto
     */
    'state'?: CourseState;
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseSectionDto
     */
    'title'?: string;
    /**
     * 
     * @type {CreateCourseSectionRequestDtoAttribute}
     * @memberof ResponseDetailCourseSectionDto
     */
    'attribute'?: CreateCourseSectionRequestDtoAttribute;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseDetailCourseSectionDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseDetailCourseSectionDto
     */
    'tagsDetail'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseSectionDto
     */
    'thumbnailUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseSectionDto
     */
    'attachmentUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseSectionDto
     */
    'attachment'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseSectionDto
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseSectionDto
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResponseDetailCourseSectionDto
     */
    'totalCredits'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResponseDetailCourseSectionDto
     */
    'videoDuration'?: number;
}


/**
 * 
 * @export
 * @interface StatusUserProgressCourseDto
 */
export interface StatusUserProgressCourseDto {
    /**
     * 
     * @type {string}
     * @memberof StatusUserProgressCourseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatusUserProgressCourseDto
     */
    'userInfoId'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatusUserProgressCourseDto
     */
    'courseId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StatusUserProgressCourseDto
     */
    'isCompletedEntranceTest'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StatusUserProgressCourseDto
     */
    'isCompletedSurveyCourse'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StatusUserProgressCourseDto
     */
    'isCompletedTotalCourseSection'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StatusUserProgressCourseDto
     */
    'isCompletedFinalCourseTest'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StatusUserProgressCourseDto
     */
    'isCompletedCourse'?: boolean;
}
/**
 * 
 * @export
 * @interface TagResponseDto
 */
export interface TagResponseDto {
    /**
     * 
     * @type {string}
     * @memberof TagResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TagResponseDto
     */
    'content'?: string;
    /**
     * 
     * @type {TagType}
     * @memberof TagResponseDto
     */
    'type'?: TagType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TagType = {
    DamageTag: 'DAMAGE_TAG',
    AnatomyLocationTag: 'ANATOMY_LOCATION_TAG',
    HpTag: 'HP_TAG',
    LightTag: 'LIGHT_TAG',
    UpperGastroAnatomyTag: 'UPPER_GASTRO_ANATOMY_TAG'
} as const;

export type TagType = typeof TagType[keyof typeof TagType];


/**
 * 
 * @export
 * @interface TestDetailResponseDto
 */
export interface TestDetailResponseDto {
    /**
     * 
     * @type {string}
     * @memberof TestDetailResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestDetailResponseDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestDetailResponseDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestDetailResponseDto
     */
    'courseId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestDetailResponseDto
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestDetailResponseDto
     */
    'state'?: string;
    /**
     * 
     * @type {Array<QuestionResponseDto>}
     * @memberof TestDetailResponseDto
     */
    'questions'?: Array<QuestionResponseDto>;
}
/**
 * 
 * @export
 * @interface TestResponseDto
 */
export interface TestResponseDto {
    /**
     * 
     * @type {string}
     * @memberof TestResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestResponseDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestResponseDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestResponseDto
     */
    'courseId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestResponseDto
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestResponseDto
     */
    'state'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCommentRequestDto
 */
export interface UpdateCommentRequestDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateCommentRequestDto
     */
    'attachments'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateCommentRequestDto
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface UpdateCourseRequestDto
 */
export interface UpdateCourseRequestDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseRequestDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseRequestDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseRequestDto
     */
    'lecturer'?: string;
    /**
     * 
     * @type {CourseState}
     * @memberof UpdateCourseRequestDto
     */
    'state'?: CourseState;
    /**
     * MinIO object key for thumbnail (uploaded via presigned URL)
     * @type {string}
     * @memberof UpdateCourseRequestDto
     */
    'thumbnail'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateCourseRequestDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateCourseRequestDto
     */
    'tagsDetail'?: Array<string>;
}


/**
 * 
 * @export
 * @interface UpdateCourseSectionRequestDto
 */
export interface UpdateCourseSectionRequestDto {
    /**
     * 
     * @type {CourseState}
     * @memberof UpdateCourseSectionRequestDto
     */
    'state'?: CourseState;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseSectionRequestDto
     */
    'title'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateCourseSectionRequestDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateCourseSectionRequestDto
     */
    'tagsDetail'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof UpdateCourseSectionRequestDto
     */
    'totalCredits'?: number;
    /**
     * 
     * @type {CreateCourseSectionRequestDtoAttribute}
     * @memberof UpdateCourseSectionRequestDto
     */
    'attribute'?: CreateCourseSectionRequestDtoAttribute;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseSectionRequestDto
     */
    'thumbnail'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseSectionRequestDto
     */
    'attachments'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateCourseSectionRequestDto
     */
    'videoDuration'?: number;
}


/**
 * 
 * @export
 * @interface UpdateDoctorUserConversationDto
 */
export interface UpdateDoctorUserConversationDto {
    /**
     * 
     * @type {DoctorUserConversationState}
     * @memberof UpdateDoctorUserConversationDto
     */
    'state'?: DoctorUserConversationState;
    /**
     * Updated content
     * @type {string}
     * @memberof UpdateDoctorUserConversationDto
     */
    'content'?: string;
    /**
     * Reassign to different doctor
     * @type {string}
     * @memberof UpdateDoctorUserConversationDto
     */
    'assigneeId'?: string;
}


/**
 * 
 * @export
 * @interface UpdateQuestionRequestDto
 */
export interface UpdateQuestionRequestDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateQuestionRequestDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateQuestionRequestDto
     */
    'description'?: string;
    /**
     * 
     * @type {QuestionType}
     * @memberof UpdateQuestionRequestDto
     */
    'type'?: QuestionType;
    /**
     * 
     * @type {object}
     * @memberof UpdateQuestionRequestDto
     */
    'answers'?: object;
    /**
     * 
     * @type {number}
     * @memberof UpdateQuestionRequestDto
     */
    'orderIndex'?: number;
    /**
     * Flag to mark question for deletion
     * @type {boolean}
     * @memberof UpdateQuestionRequestDto
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {Array<QuestionAttachmentCreateDto>}
     * @memberof UpdateQuestionRequestDto
     */
    'attachments'?: Array<QuestionAttachmentCreateDto>;
}


/**
 * 
 * @export
 * @interface UpdateResourceRequestDto
 */
export interface UpdateResourceRequestDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateResourceRequestDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateResourceRequestDto
     */
    'description'?: string;
    /**
     * 
     * @type {ResourceState}
     * @memberof UpdateResourceRequestDto
     */
    'state'?: ResourceState;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateResourceRequestDto
     */
    'tag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateResourceRequestDto
     */
    'detailTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateResourceRequestDto
     */
    'anatomyLocationTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateResourceRequestDto
     */
    'lightTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateResourceRequestDto
     */
    'hpTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateResourceRequestDto
     */
    'upperGastroAnatomyTag'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateResourceRequestDto
     */
    'thumbnail'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateResourceRequestDto
     */
    'attachment'?: string;
}


/**
 * 
 * @export
 * @interface UpdateTestRequestDto
 */
export interface UpdateTestRequestDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateTestRequestDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTestRequestDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTestRequestDto
     */
    'courseId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTestRequestDto
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTestRequestDto
     */
    'state'?: string;
    /**
     * 
     * @type {Array<UpdateQuestionRequestDto>}
     * @memberof UpdateTestRequestDto
     */
    'questions'?: Array<UpdateQuestionRequestDto>;
}
/**
 * 
 * @export
 * @interface UpdateUserRequestDto
 */
export interface UpdateUserRequestDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequestDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequestDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequestDto
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {UserInfoRole}
     * @memberof UpdateUserRequestDto
     */
    'role'?: UserInfoRole;
    /**
     * 
     * @type {UserInfoState}
     * @memberof UpdateUserRequestDto
     */
    'state'?: UserInfoState;
    /**
     * MinIO object key for avatar (uploaded via presigned URL)
     * @type {string}
     * @memberof UpdateUserRequestDto
     */
    'avatar'?: string;
    /**
     * List of certificate object keys to delete
     * @type {Array<string>}
     * @memberof UpdateUserRequestDto
     */
    'deleteCertificatePaths'?: Array<string>;
    /**
     * List of new certificate object keys (uploaded via presigned URL)
     * @type {Array<string>}
     * @memberof UpdateUserRequestDto
     */
    'newCertificates'?: Array<string>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const UploadType = {
    Video: 'VIDEO',
    Image: 'IMAGE',
    Compressed: 'COMPRESSED',
    Other: 'OTHER'
} as const;

export type UploadType = typeof UploadType[keyof typeof UploadType];


/**
 * 
 * @export
 * @interface UserCourseResponseDto
 */
export interface UserCourseResponseDto {
    /**
     * 
     * @type {string}
     * @memberof UserCourseResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCourseResponseDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCourseResponseDto
     */
    'title'?: string;
    /**
     * 
     * @type {CourseState}
     * @memberof UserCourseResponseDto
     */
    'state'?: CourseState;
    /**
     * 
     * @type {string}
     * @memberof UserCourseResponseDto
     */
    'thumbnailUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCourseResponseDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCourseResponseDto
     */
    'updatedAt'?: string;
}


/**
 * 
 * @export
 * @interface UserCourseResponsePaginatedDto
 */
export interface UserCourseResponsePaginatedDto {
    /**
     * 
     * @type {Array<UserCourseResponseDto>}
     * @memberof UserCourseResponsePaginatedDto
     */
    'data'?: Array<UserCourseResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof UserCourseResponsePaginatedDto
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface UserInfoCriteria
 */
export interface UserInfoCriteria {
    /**
     * 
     * @type {string}
     * @memberof UserInfoCriteria
     */
    'searchWord'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserInfoCriteria
     */
    'emails'?: Array<string>;
    /**
     * 
     * @type {UserInfoRole}
     * @memberof UserInfoCriteria
     */
    'role'?: UserInfoRole;
    /**
     * 
     * @type {UserInfoState}
     * @memberof UserInfoCriteria
     */
    'state'?: UserInfoState;
    /**
     * 
     * @type {string}
     * @memberof UserInfoCriteria
     */
    'fromDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoCriteria
     */
    'toDate'?: string;
}


/**
 * 
 * @export
 * @interface UserInfoDto
 */
export interface UserInfoDto {
    /**
     * 
     * @type {string}
     * @memberof UserInfoDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoDto
     */
    'avatarUrl'?: string;
}
/**
 * 
 * @export
 * @interface UserInfoEnrollCourseDto
 */
export interface UserInfoEnrollCourseDto {
    /**
     * 
     * @type {string}
     * @memberof UserInfoEnrollCourseDto
     */
    'userInfoId': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UserInfoRole = {
    Admin: 'ADMIN',
    Specialist: 'SPECIALIST',
    Coordinator: 'COORDINATOR',
    Customer: 'CUSTOMER'
} as const;

export type UserInfoRole = typeof UserInfoRole[keyof typeof UserInfoRole];


/**
 * 
 * @export
 * @enum {string}
 */

export const UserInfoState = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Pending: 'PENDING',
    Suspended: 'SUSPENDED'
} as const;

export type UserInfoState = typeof UserInfoState[keyof typeof UserInfoState];


/**
 * 
 * @export
 * @interface UserProgressCourseDto
 */
export interface UserProgressCourseDto {
    /**
     * 
     * @type {string}
     * @memberof UserProgressCourseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProgressCourseDto
     */
    'courseId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProgressCourseDto
     */
    'courseTitle'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserProgressCourseDto
     */
    'totalLectures'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserProgressCourseDto
     */
    'numberLecturesCompleted'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserProgressCourseDto
     */
    'thumbnailUrl'?: string;
}
/**
 * 
 * @export
 * @interface UserResourceDetailResponseDto
 */
export interface UserResourceDetailResponseDto {
    /**
     * 
     * @type {string}
     * @memberof UserResourceDetailResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResourceDetailResponseDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResourceDetailResponseDto
     */
    'resourceUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResourceDetailResponseDto
     */
    'dimension'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResourceDetailResponseDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResourceDetailResponseDto
     */
    'extension'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserResourceDetailResponseDto
     */
    'tag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserResourceDetailResponseDto
     */
    'detailTag'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof UserResourceDetailResponseDto
     */
    'time'?: number;
    /**
     * 
     * @type {ResourceType}
     * @memberof UserResourceDetailResponseDto
     */
    'type'?: ResourceType;
    /**
     * 
     * @type {string}
     * @memberof UserResourceDetailResponseDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResourceDetailResponseDto
     */
    'createdBy'?: string;
    /**
     * 
     * @type {UserInfoDto}
     * @memberof UserResourceDetailResponseDto
     */
    'createdByInfo'?: UserInfoDto;
}


/**
 * 
 * @export
 * @interface UserResourceHistoryCriteria
 */
export interface UserResourceHistoryCriteria {
    /**
     * 
     * @type {string}
     * @memberof UserResourceHistoryCriteria
     */
    'userInfoId': string;
    /**
     * 
     * @type {UserResourceType}
     * @memberof UserResourceHistoryCriteria
     */
    'type': UserResourceType;
}


/**
 * 
 * @export
 * @interface UserResourceResponseDto
 */
export interface UserResourceResponseDto {
    /**
     * ID of the resource
     * @type {string}
     * @memberof UserResourceResponseDto
     */
    'id'?: string;
    /**
     * Title of the resource
     * @type {string}
     * @memberof UserResourceResponseDto
     */
    'title'?: string;
    /**
     * URL of thumbnail
     * @type {string}
     * @memberof UserResourceResponseDto
     */
    'thumbnailUrl'?: string;
    /**
     * 
     * @type {ResourceType}
     * @memberof UserResourceResponseDto
     */
    'type'?: ResourceType;
    /**
     * 
     * @type {string}
     * @memberof UserResourceResponseDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResourceResponseDto
     */
    'createdBy'?: string;
    /**
     * 
     * @type {UserInfoDto}
     * @memberof UserResourceResponseDto
     */
    'createdByInfo'?: UserInfoDto;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserResourceResponseDto
     */
    'tag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserResourceResponseDto
     */
    'detailTag'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof UserResourceResponseDto
     */
    'time'?: number;
}


/**
 * 
 * @export
 * @interface UserResourceResponsePaginatedDto
 */
export interface UserResourceResponsePaginatedDto {
    /**
     * 
     * @type {Array<UserResourceResponseDto>}
     * @memberof UserResourceResponsePaginatedDto
     */
    'data'?: Array<UserResourceResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof UserResourceResponsePaginatedDto
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UserResourceType = {
    Image: 'IMAGE',
    Video: 'VIDEO'
} as const;

export type UserResourceType = typeof UserResourceType[keyof typeof UserResourceType];


/**
 * 
 * @export
 * @interface UserResourcesAccessedResponseDto
 */
export interface UserResourcesAccessedResponseDto {
    /**
     * 
     * @type {ResourceResponseDto}
     * @memberof UserResourcesAccessedResponseDto
     */
    'resource'?: ResourceResponseDto;
    /**
     * 
     * @type {string}
     * @memberof UserResourcesAccessedResponseDto
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface UserResourcesAccessedResponsePaginatedDto
 */
export interface UserResourcesAccessedResponsePaginatedDto {
    /**
     * 
     * @type {Array<UserResourcesAccessedResponseDto>}
     * @memberof UserResourcesAccessedResponsePaginatedDto
     */
    'data'?: Array<UserResourcesAccessedResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof UserResourcesAccessedResponsePaginatedDto
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface UserResponseDetailCourseDto
 */
export interface UserResponseDetailCourseDto {
    /**
     * 
     * @type {string}
     * @memberof UserResponseDetailCourseDto
     */
    'id'?: string;
    /**
     * 
     * @type {CourseState}
     * @memberof UserResponseDetailCourseDto
     */
    'state'?: CourseState;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDetailCourseDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDetailCourseDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDetailCourseDto
     */
    'lecturer'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserResponseDetailCourseDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserResponseDetailCourseDto
     */
    'tagsDetail'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDetailCourseDto
     */
    'thumbnailUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDetailCourseDto
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDetailCourseDto
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserResponseDetailCourseDto
     */
    'participantsCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDetailCourseDto
     */
    'userRegistrationCourseId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponseDetailCourseDto
     */
    'isEnrolledCourse'?: boolean;
    /**
     * 
     * @type {UserInfoDto}
     * @memberof UserResponseDetailCourseDto
     */
    'createdByInfo'?: UserInfoDto;
}


/**
 * 
 * @export
 * @interface UserResponseDto
 */
export interface UserResponseDto {
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {UserInfoState}
     * @memberof UserResponseDto
     */
    'state'?: UserInfoState;
    /**
     * 
     * @type {UserInfoRole}
     * @memberof UserResponseDto
     */
    'role'?: UserInfoRole;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'avatarPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'avatarLink'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserResponseDto
     */
    'certificateLinks'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponseDto
     */
    'isUpdatedProfile'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'updatedAt'?: string;
}


/**
 * 
 * @export
 * @interface UserResponsePaginatedDto
 */
export interface UserResponsePaginatedDto {
    /**
     * 
     * @type {Array<UserResponseDto>}
     * @memberof UserResponsePaginatedDto
     */
    'data'?: Array<UserResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof UserResponsePaginatedDto
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface WebhookKeycloakRequestDto
 */
export interface WebhookKeycloakRequestDto {
    /**
     * 
     * @type {string}
     * @memberof WebhookKeycloakRequestDto
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookKeycloakRequestDto
     */
    'realmId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookKeycloakRequestDto
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookKeycloakRequestDto
     */
    'resourceType'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookKeycloakRequestDto
     */
    'operationType'?: string;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof WebhookKeycloakRequestDto
     */
    'details'?: { [key: string]: any | undefined; };
    /**
     * 
     * @type {object}
     * @memberof WebhookKeycloakRequestDto
     */
    'authDetails'?: object;
}
/**
 * 
 * @export
 * @interface WebhookMinIOEventDto
 */
export interface WebhookMinIOEventDto {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof WebhookMinIOEventDto
     */
    'EventName'?: string;
    /**
     * <bucket>/<object_key>
     * @type {string}
     * @memberof WebhookMinIOEventDto
     */
    'Key'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof WebhookMinIOEventDto
     */
    'Records'?: Array<object>;
}

/**
 * ActuatorApi - axios parameter creator
 * @export
 */
export const ActuatorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get health status of backend service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actuatorHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/actuator/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActuatorApi - functional programming interface
 * @export
 */
export const ActuatorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActuatorApiAxiosParamCreator(configuration)
    return {
        /**
         * Get health status of backend service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actuatorHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actuatorHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActuatorApi.actuatorHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActuatorApi - factory interface
 * @export
 */
export const ActuatorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActuatorApiFp(configuration)
    return {
        /**
         * Get health status of backend service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actuatorHealth(options?: RawAxiosRequestConfig): AxiosPromise<HealthResponseDto> {
            return localVarFp.actuatorHealth(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActuatorApi - object-oriented interface
 * @export
 * @class ActuatorApi
 * @extends {BaseAPI}
 */
export class ActuatorApi extends BaseAPI {
    /**
     * Get health status of backend service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApi
     */
    public actuatorHealth(options?: RawAxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).actuatorHealth(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CommentV1Api - axios parameter creator
 * @export
 */
export const CommentV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new comment
         * @param {CreateCommentRequestDto} createCommentRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment: async (createCommentRequestDto: CreateCommentRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCommentRequestDto' is not null or undefined
            assertParamExists('createComment', 'createCommentRequestDto', createCommentRequestDto)
            const localVarPath = `/api/v1/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCommentRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a comment by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteComment', 'id', id)
            const localVarPath = `/api/v1/comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all comments with criteria
         * @param {CommentCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments: async (criteria?: CommentCriteria, pageable?: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (criteria !== undefined) {
                for (const [key, value] of Object.entries(criteria)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a comment by ID
         * @param {string} id 
         * @param {UpdateCommentRequestDto} updateCommentRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateComment: async (id: string, updateCommentRequestDto: UpdateCommentRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateComment', 'id', id)
            // verify required parameter 'updateCommentRequestDto' is not null or undefined
            assertParamExists('updateComment', 'updateCommentRequestDto', updateCommentRequestDto)
            const localVarPath = `/api/v1/comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCommentRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentV1Api - functional programming interface
 * @export
 */
export const CommentV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommentV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new comment
         * @param {CreateCommentRequestDto} createCommentRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createComment(createCommentRequestDto: CreateCommentRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdWrapperDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createComment(createCommentRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentV1Api.createComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a comment by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteComment(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteComment(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentV1Api.deleteComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all comments with criteria
         * @param {CommentCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getComments(criteria?: CommentCriteria, pageable?: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentResponsePaginatedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getComments(criteria, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentV1Api.getComments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a comment by ID
         * @param {string} id 
         * @param {UpdateCommentRequestDto} updateCommentRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateComment(id: string, updateCommentRequestDto: UpdateCommentRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateComment(id, updateCommentRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentV1Api.updateComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CommentV1Api - factory interface
 * @export
 */
export const CommentV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommentV1ApiFp(configuration)
    return {
        /**
         * Create a new comment
         * @param {CommentV1ApiCreateCommentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment(requestParameters: CommentV1ApiCreateCommentRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdWrapperDto> {
            return localVarFp.createComment(requestParameters.createCommentRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a comment by ID
         * @param {CommentV1ApiDeleteCommentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment(requestParameters: CommentV1ApiDeleteCommentRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteComment(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all comments with criteria
         * @param {CommentV1ApiGetCommentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(requestParameters: CommentV1ApiGetCommentsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CommentResponsePaginatedDto> {
            return localVarFp.getComments(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a comment by ID
         * @param {CommentV1ApiUpdateCommentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateComment(requestParameters: CommentV1ApiUpdateCommentRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommentResponseDto> {
            return localVarFp.updateComment(requestParameters.id, requestParameters.updateCommentRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createComment operation in CommentV1Api.
 * @export
 * @interface CommentV1ApiCreateCommentRequest
 */
export interface CommentV1ApiCreateCommentRequest {
    /**
     * 
     * @type {CreateCommentRequestDto}
     * @memberof CommentV1ApiCreateComment
     */
    readonly createCommentRequestDto: CreateCommentRequestDto
}

/**
 * Request parameters for deleteComment operation in CommentV1Api.
 * @export
 * @interface CommentV1ApiDeleteCommentRequest
 */
export interface CommentV1ApiDeleteCommentRequest {
    /**
     * 
     * @type {string}
     * @memberof CommentV1ApiDeleteComment
     */
    readonly id: string
}

/**
 * Request parameters for getComments operation in CommentV1Api.
 * @export
 * @interface CommentV1ApiGetCommentsRequest
 */
export interface CommentV1ApiGetCommentsRequest {
    /**
     * 
     * @type {CommentCriteria}
     * @memberof CommentV1ApiGetComments
     */
    readonly criteria?: CommentCriteria

    /**
     * 
     * @type {Pageable}
     * @memberof CommentV1ApiGetComments
     */
    readonly pageable?: Pageable
}

/**
 * Request parameters for updateComment operation in CommentV1Api.
 * @export
 * @interface CommentV1ApiUpdateCommentRequest
 */
export interface CommentV1ApiUpdateCommentRequest {
    /**
     * 
     * @type {string}
     * @memberof CommentV1ApiUpdateComment
     */
    readonly id: string

    /**
     * 
     * @type {UpdateCommentRequestDto}
     * @memberof CommentV1ApiUpdateComment
     */
    readonly updateCommentRequestDto: UpdateCommentRequestDto
}

/**
 * CommentV1Api - object-oriented interface
 * @export
 * @class CommentV1Api
 * @extends {BaseAPI}
 */
export class CommentV1Api extends BaseAPI {
    /**
     * Create a new comment
     * @param {CommentV1ApiCreateCommentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentV1Api
     */
    public createComment(requestParameters: CommentV1ApiCreateCommentRequest, options?: RawAxiosRequestConfig) {
        return CommentV1ApiFp(this.configuration).createComment(requestParameters.createCommentRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a comment by ID
     * @param {CommentV1ApiDeleteCommentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentV1Api
     */
    public deleteComment(requestParameters: CommentV1ApiDeleteCommentRequest, options?: RawAxiosRequestConfig) {
        return CommentV1ApiFp(this.configuration).deleteComment(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all comments with criteria
     * @param {CommentV1ApiGetCommentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentV1Api
     */
    public getComments(requestParameters: CommentV1ApiGetCommentsRequest = {}, options?: RawAxiosRequestConfig) {
        return CommentV1ApiFp(this.configuration).getComments(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a comment by ID
     * @param {CommentV1ApiUpdateCommentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentV1Api
     */
    public updateComment(requestParameters: CommentV1ApiUpdateCommentRequest, options?: RawAxiosRequestConfig) {
        return CommentV1ApiFp(this.configuration).updateComment(requestParameters.id, requestParameters.updateCommentRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CourseSectionV1Api - axios parameter creator
 * @export
 */
export const CourseSectionV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new course section
         * @param {CreateCourseSectionRequestDto} createCourseSectionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseSection: async (createCourseSectionRequestDto: CreateCourseSectionRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCourseSectionRequestDto' is not null or undefined
            assertParamExists('createCourseSection', 'createCourseSectionRequestDto', createCourseSectionRequestDto)
            const localVarPath = `/api/v1/course-sections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCourseSectionRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a course section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseSection: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCourseSection', 'id', id)
            const localVarPath = `/api/v1/course-sections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete course sections by list of ids
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseSections: async (ids: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteCourseSections', 'ids', ids)
            const localVarPath = `/api/v1/course-sections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get course section by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseSectionById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCourseSectionById', 'id', id)
            const localVarPath = `/api/v1/course-sections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get course sections by criteria
         * @param {CourseSectionCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseSections: async (criteria?: CourseSectionCriteria, pageable?: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/course-sections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (criteria !== undefined) {
                for (const [key, value] of Object.entries(criteria)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update course section
         * @param {string} id 
         * @param {UpdateCourseSectionRequestDto} metadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseSection: async (id: string, metadata: UpdateCourseSectionRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCourseSection', 'id', id)
            // verify required parameter 'metadata' is not null or undefined
            assertParamExists('updateCourseSection', 'metadata', metadata)
            const localVarPath = `/api/v1/course-sections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (metadata !== undefined) { 
                localVarFormParams.append('metadata', new Blob([JSON.stringify(metadata)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseSectionV1Api - functional programming interface
 * @export
 */
export const CourseSectionV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseSectionV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new course section
         * @param {CreateCourseSectionRequestDto} createCourseSectionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCourseSection(createCourseSectionRequestDto: CreateCourseSectionRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdWrapperDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCourseSection(createCourseSectionRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseSectionV1Api.createCourseSection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a course section
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCourseSection(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCourseSection(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseSectionV1Api.deleteCourseSection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete course sections by list of ids
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCourseSections(ids: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCourseSections(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseSectionV1Api.deleteCourseSections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get course section by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseSectionById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDetailCourseSectionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseSectionById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseSectionV1Api.getCourseSectionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get course sections by criteria
         * @param {CourseSectionCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseSections(criteria?: CourseSectionCriteria, pageable?: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseSectionResponsePaginatedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseSections(criteria, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseSectionV1Api.getCourseSections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update course section
         * @param {string} id 
         * @param {UpdateCourseSectionRequestDto} metadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCourseSection(id: string, metadata: UpdateCourseSectionRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdWrapperDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCourseSection(id, metadata, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseSectionV1Api.updateCourseSection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CourseSectionV1Api - factory interface
 * @export
 */
export const CourseSectionV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseSectionV1ApiFp(configuration)
    return {
        /**
         * Create a new course section
         * @param {CourseSectionV1ApiCreateCourseSectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseSection(requestParameters: CourseSectionV1ApiCreateCourseSectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdWrapperDto> {
            return localVarFp.createCourseSection(requestParameters.createCourseSectionRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a course section
         * @param {CourseSectionV1ApiDeleteCourseSectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseSection(requestParameters: CourseSectionV1ApiDeleteCourseSectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCourseSection(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete course sections by list of ids
         * @param {CourseSectionV1ApiDeleteCourseSectionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseSections(requestParameters: CourseSectionV1ApiDeleteCourseSectionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCourseSections(requestParameters.ids, options).then((request) => request(axios, basePath));
        },
        /**
         * Get course section by ID
         * @param {CourseSectionV1ApiGetCourseSectionByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseSectionById(requestParameters: CourseSectionV1ApiGetCourseSectionByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResponseDetailCourseSectionDto> {
            return localVarFp.getCourseSectionById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get course sections by criteria
         * @param {CourseSectionV1ApiGetCourseSectionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseSections(requestParameters: CourseSectionV1ApiGetCourseSectionsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CourseSectionResponsePaginatedDto> {
            return localVarFp.getCourseSections(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Update course section
         * @param {CourseSectionV1ApiUpdateCourseSectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseSection(requestParameters: CourseSectionV1ApiUpdateCourseSectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdWrapperDto> {
            return localVarFp.updateCourseSection(requestParameters.id, requestParameters.metadata, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCourseSection operation in CourseSectionV1Api.
 * @export
 * @interface CourseSectionV1ApiCreateCourseSectionRequest
 */
export interface CourseSectionV1ApiCreateCourseSectionRequest {
    /**
     * 
     * @type {CreateCourseSectionRequestDto}
     * @memberof CourseSectionV1ApiCreateCourseSection
     */
    readonly createCourseSectionRequestDto: CreateCourseSectionRequestDto
}

/**
 * Request parameters for deleteCourseSection operation in CourseSectionV1Api.
 * @export
 * @interface CourseSectionV1ApiDeleteCourseSectionRequest
 */
export interface CourseSectionV1ApiDeleteCourseSectionRequest {
    /**
     * 
     * @type {string}
     * @memberof CourseSectionV1ApiDeleteCourseSection
     */
    readonly id: string
}

/**
 * Request parameters for deleteCourseSections operation in CourseSectionV1Api.
 * @export
 * @interface CourseSectionV1ApiDeleteCourseSectionsRequest
 */
export interface CourseSectionV1ApiDeleteCourseSectionsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CourseSectionV1ApiDeleteCourseSections
     */
    readonly ids: Array<string>
}

/**
 * Request parameters for getCourseSectionById operation in CourseSectionV1Api.
 * @export
 * @interface CourseSectionV1ApiGetCourseSectionByIdRequest
 */
export interface CourseSectionV1ApiGetCourseSectionByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof CourseSectionV1ApiGetCourseSectionById
     */
    readonly id: string
}

/**
 * Request parameters for getCourseSections operation in CourseSectionV1Api.
 * @export
 * @interface CourseSectionV1ApiGetCourseSectionsRequest
 */
export interface CourseSectionV1ApiGetCourseSectionsRequest {
    /**
     * 
     * @type {CourseSectionCriteria}
     * @memberof CourseSectionV1ApiGetCourseSections
     */
    readonly criteria?: CourseSectionCriteria

    /**
     * 
     * @type {Pageable}
     * @memberof CourseSectionV1ApiGetCourseSections
     */
    readonly pageable?: Pageable
}

/**
 * Request parameters for updateCourseSection operation in CourseSectionV1Api.
 * @export
 * @interface CourseSectionV1ApiUpdateCourseSectionRequest
 */
export interface CourseSectionV1ApiUpdateCourseSectionRequest {
    /**
     * 
     * @type {string}
     * @memberof CourseSectionV1ApiUpdateCourseSection
     */
    readonly id: string

    /**
     * 
     * @type {UpdateCourseSectionRequestDto}
     * @memberof CourseSectionV1ApiUpdateCourseSection
     */
    readonly metadata: UpdateCourseSectionRequestDto
}

/**
 * CourseSectionV1Api - object-oriented interface
 * @export
 * @class CourseSectionV1Api
 * @extends {BaseAPI}
 */
export class CourseSectionV1Api extends BaseAPI {
    /**
     * Create a new course section
     * @param {CourseSectionV1ApiCreateCourseSectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseSectionV1Api
     */
    public createCourseSection(requestParameters: CourseSectionV1ApiCreateCourseSectionRequest, options?: RawAxiosRequestConfig) {
        return CourseSectionV1ApiFp(this.configuration).createCourseSection(requestParameters.createCourseSectionRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a course section
     * @param {CourseSectionV1ApiDeleteCourseSectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseSectionV1Api
     */
    public deleteCourseSection(requestParameters: CourseSectionV1ApiDeleteCourseSectionRequest, options?: RawAxiosRequestConfig) {
        return CourseSectionV1ApiFp(this.configuration).deleteCourseSection(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete course sections by list of ids
     * @param {CourseSectionV1ApiDeleteCourseSectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseSectionV1Api
     */
    public deleteCourseSections(requestParameters: CourseSectionV1ApiDeleteCourseSectionsRequest, options?: RawAxiosRequestConfig) {
        return CourseSectionV1ApiFp(this.configuration).deleteCourseSections(requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get course section by ID
     * @param {CourseSectionV1ApiGetCourseSectionByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseSectionV1Api
     */
    public getCourseSectionById(requestParameters: CourseSectionV1ApiGetCourseSectionByIdRequest, options?: RawAxiosRequestConfig) {
        return CourseSectionV1ApiFp(this.configuration).getCourseSectionById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get course sections by criteria
     * @param {CourseSectionV1ApiGetCourseSectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseSectionV1Api
     */
    public getCourseSections(requestParameters: CourseSectionV1ApiGetCourseSectionsRequest = {}, options?: RawAxiosRequestConfig) {
        return CourseSectionV1ApiFp(this.configuration).getCourseSections(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update course section
     * @param {CourseSectionV1ApiUpdateCourseSectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseSectionV1Api
     */
    public updateCourseSection(requestParameters: CourseSectionV1ApiUpdateCourseSectionRequest, options?: RawAxiosRequestConfig) {
        return CourseSectionV1ApiFp(this.configuration).updateCourseSection(requestParameters.id, requestParameters.metadata, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CourseV1Api - axios parameter creator
 * @export
 */
export const CourseV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new course
         * @param {CreateCourseRequestDto} createCourseRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourse: async (createCourseRequestDto: CreateCourseRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCourseRequestDto' is not null or undefined
            assertParamExists('createCourse', 'createCourseRequestDto', createCourseRequestDto)
            const localVarPath = `/api/v1/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCourseRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete course
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourse: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCourse', 'id', id)
            const localVarPath = `/api/v1/courses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get course by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCourseById', 'id', id)
            const localVarPath = `/api/v1/courses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get courses by criteria
         * @param {CourseCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses: async (criteria?: CourseCriteria, pageable?: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (criteria !== undefined) {
                for (const [key, value] of Object.entries(criteria)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update course
         * @param {string} id 
         * @param {UpdateCourseRequestDto} updateCourseRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourse: async (id: string, updateCourseRequestDto: UpdateCourseRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCourse', 'id', id)
            // verify required parameter 'updateCourseRequestDto' is not null or undefined
            assertParamExists('updateCourse', 'updateCourseRequestDto', updateCourseRequestDto)
            const localVarPath = `/api/v1/courses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCourseRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseV1Api - functional programming interface
 * @export
 */
export const CourseV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new course
         * @param {CreateCourseRequestDto} createCourseRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCourse(createCourseRequestDto: CreateCourseRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdWrapperDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCourse(createCourseRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseV1Api.createCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete course
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCourse(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCourse(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseV1Api.deleteCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get course by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseDetailResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseV1Api.getCourseById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get courses by criteria
         * @param {CourseCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourses(criteria?: CourseCriteria, pageable?: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseResponsePaginatedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourses(criteria, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseV1Api.getCourses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update course
         * @param {string} id 
         * @param {UpdateCourseRequestDto} updateCourseRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCourse(id: string, updateCourseRequestDto: UpdateCourseRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseDetailResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCourse(id, updateCourseRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseV1Api.updateCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CourseV1Api - factory interface
 * @export
 */
export const CourseV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseV1ApiFp(configuration)
    return {
        /**
         * Create a new course
         * @param {CourseV1ApiCreateCourseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourse(requestParameters: CourseV1ApiCreateCourseRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdWrapperDto> {
            return localVarFp.createCourse(requestParameters.createCourseRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete course
         * @param {CourseV1ApiDeleteCourseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourse(requestParameters: CourseV1ApiDeleteCourseRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCourse(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get course by ID
         * @param {CourseV1ApiGetCourseByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseById(requestParameters: CourseV1ApiGetCourseByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<CourseDetailResponseDto> {
            return localVarFp.getCourseById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get courses by criteria
         * @param {CourseV1ApiGetCoursesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses(requestParameters: CourseV1ApiGetCoursesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CourseResponsePaginatedDto> {
            return localVarFp.getCourses(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Update course
         * @param {CourseV1ApiUpdateCourseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourse(requestParameters: CourseV1ApiUpdateCourseRequest, options?: RawAxiosRequestConfig): AxiosPromise<CourseDetailResponseDto> {
            return localVarFp.updateCourse(requestParameters.id, requestParameters.updateCourseRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCourse operation in CourseV1Api.
 * @export
 * @interface CourseV1ApiCreateCourseRequest
 */
export interface CourseV1ApiCreateCourseRequest {
    /**
     * 
     * @type {CreateCourseRequestDto}
     * @memberof CourseV1ApiCreateCourse
     */
    readonly createCourseRequestDto: CreateCourseRequestDto
}

/**
 * Request parameters for deleteCourse operation in CourseV1Api.
 * @export
 * @interface CourseV1ApiDeleteCourseRequest
 */
export interface CourseV1ApiDeleteCourseRequest {
    /**
     * 
     * @type {string}
     * @memberof CourseV1ApiDeleteCourse
     */
    readonly id: string
}

/**
 * Request parameters for getCourseById operation in CourseV1Api.
 * @export
 * @interface CourseV1ApiGetCourseByIdRequest
 */
export interface CourseV1ApiGetCourseByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof CourseV1ApiGetCourseById
     */
    readonly id: string
}

/**
 * Request parameters for getCourses operation in CourseV1Api.
 * @export
 * @interface CourseV1ApiGetCoursesRequest
 */
export interface CourseV1ApiGetCoursesRequest {
    /**
     * 
     * @type {CourseCriteria}
     * @memberof CourseV1ApiGetCourses
     */
    readonly criteria?: CourseCriteria

    /**
     * 
     * @type {Pageable}
     * @memberof CourseV1ApiGetCourses
     */
    readonly pageable?: Pageable
}

/**
 * Request parameters for updateCourse operation in CourseV1Api.
 * @export
 * @interface CourseV1ApiUpdateCourseRequest
 */
export interface CourseV1ApiUpdateCourseRequest {
    /**
     * 
     * @type {string}
     * @memberof CourseV1ApiUpdateCourse
     */
    readonly id: string

    /**
     * 
     * @type {UpdateCourseRequestDto}
     * @memberof CourseV1ApiUpdateCourse
     */
    readonly updateCourseRequestDto: UpdateCourseRequestDto
}

/**
 * CourseV1Api - object-oriented interface
 * @export
 * @class CourseV1Api
 * @extends {BaseAPI}
 */
export class CourseV1Api extends BaseAPI {
    /**
     * Create a new course
     * @param {CourseV1ApiCreateCourseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public createCourse(requestParameters: CourseV1ApiCreateCourseRequest, options?: RawAxiosRequestConfig) {
        return CourseV1ApiFp(this.configuration).createCourse(requestParameters.createCourseRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete course
     * @param {CourseV1ApiDeleteCourseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public deleteCourse(requestParameters: CourseV1ApiDeleteCourseRequest, options?: RawAxiosRequestConfig) {
        return CourseV1ApiFp(this.configuration).deleteCourse(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get course by ID
     * @param {CourseV1ApiGetCourseByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public getCourseById(requestParameters: CourseV1ApiGetCourseByIdRequest, options?: RawAxiosRequestConfig) {
        return CourseV1ApiFp(this.configuration).getCourseById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get courses by criteria
     * @param {CourseV1ApiGetCoursesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public getCourses(requestParameters: CourseV1ApiGetCoursesRequest = {}, options?: RawAxiosRequestConfig) {
        return CourseV1ApiFp(this.configuration).getCourses(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update course
     * @param {CourseV1ApiUpdateCourseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public updateCourse(requestParameters: CourseV1ApiUpdateCourseRequest, options?: RawAxiosRequestConfig) {
        return CourseV1ApiFp(this.configuration).updateCourse(requestParameters.id, requestParameters.updateCourseRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DoctorUserConversationsV1Api - axios parameter creator
 * @export
 */
export const DoctorUserConversationsV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a conversation/question between doctor and user (questioner auto-filled from JWT)
         * @param {CreateDoctorUserConversationDto} createDoctorUserConversationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationDoctorAndUser: async (createDoctorUserConversationDto: CreateDoctorUserConversationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDoctorUserConversationDto' is not null or undefined
            assertParamExists('createConversationDoctorAndUser', 'createDoctorUserConversationDto', createDoctorUserConversationDto)
            const localVarPath = `/api/v1/doctor-user-conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDoctorUserConversationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete conversation (admin only)
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDoctorUserConversation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDoctorUserConversation', 'id', id)
            const localVarPath = `/api/v1/doctor-user-conversations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get conversation by ID with replies
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDoctorUserConversationById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDoctorUserConversationById', 'id', id)
            const localVarPath = `/api/v1/doctor-user-conversations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get doctor-user conversations by resource
         * @param {DoctorUserConversationCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDoctorUserConversations: async (criteria?: DoctorUserConversationCriteria, pageable?: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/doctor-user-conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (criteria !== undefined) {
                for (const [key, value] of Object.entries(criteria)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update conversation (admin/assignee only)
         * @param {string} id 
         * @param {UpdateDoctorUserConversationDto} updateDoctorUserConversationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDoctorUserConversation: async (id: string, updateDoctorUserConversationDto: UpdateDoctorUserConversationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDoctorUserConversation', 'id', id)
            // verify required parameter 'updateDoctorUserConversationDto' is not null or undefined
            assertParamExists('updateDoctorUserConversation', 'updateDoctorUserConversationDto', updateDoctorUserConversationDto)
            const localVarPath = `/api/v1/doctor-user-conversations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDoctorUserConversationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DoctorUserConversationsV1Api - functional programming interface
 * @export
 */
export const DoctorUserConversationsV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DoctorUserConversationsV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a conversation/question between doctor and user (questioner auto-filled from JWT)
         * @param {CreateDoctorUserConversationDto} createDoctorUserConversationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConversationDoctorAndUser(createDoctorUserConversationDto: CreateDoctorUserConversationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdWrapperDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConversationDoctorAndUser(createDoctorUserConversationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DoctorUserConversationsV1Api.createConversationDoctorAndUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete conversation (admin only)
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDoctorUserConversation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDoctorUserConversation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DoctorUserConversationsV1Api.deleteDoctorUserConversation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get conversation by ID with replies
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDoctorUserConversationById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DoctorUserConversationResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDoctorUserConversationById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DoctorUserConversationsV1Api.getDoctorUserConversationById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get doctor-user conversations by resource
         * @param {DoctorUserConversationCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDoctorUserConversations(criteria?: DoctorUserConversationCriteria, pageable?: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DoctorUserConversationResponsePaginatedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDoctorUserConversations(criteria, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DoctorUserConversationsV1Api.getDoctorUserConversations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update conversation (admin/assignee only)
         * @param {string} id 
         * @param {UpdateDoctorUserConversationDto} updateDoctorUserConversationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDoctorUserConversation(id: string, updateDoctorUserConversationDto: UpdateDoctorUserConversationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDoctorUserConversation(id, updateDoctorUserConversationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DoctorUserConversationsV1Api.updateDoctorUserConversation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DoctorUserConversationsV1Api - factory interface
 * @export
 */
export const DoctorUserConversationsV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DoctorUserConversationsV1ApiFp(configuration)
    return {
        /**
         * Create a conversation/question between doctor and user (questioner auto-filled from JWT)
         * @param {DoctorUserConversationsV1ApiCreateConversationDoctorAndUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationDoctorAndUser(requestParameters: DoctorUserConversationsV1ApiCreateConversationDoctorAndUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdWrapperDto> {
            return localVarFp.createConversationDoctorAndUser(requestParameters.createDoctorUserConversationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete conversation (admin only)
         * @param {DoctorUserConversationsV1ApiDeleteDoctorUserConversationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDoctorUserConversation(requestParameters: DoctorUserConversationsV1ApiDeleteDoctorUserConversationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDoctorUserConversation(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get conversation by ID with replies
         * @param {DoctorUserConversationsV1ApiGetDoctorUserConversationByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDoctorUserConversationById(requestParameters: DoctorUserConversationsV1ApiGetDoctorUserConversationByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<DoctorUserConversationResponseDto> {
            return localVarFp.getDoctorUserConversationById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get doctor-user conversations by resource
         * @param {DoctorUserConversationsV1ApiGetDoctorUserConversationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDoctorUserConversations(requestParameters: DoctorUserConversationsV1ApiGetDoctorUserConversationsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<DoctorUserConversationResponsePaginatedDto> {
            return localVarFp.getDoctorUserConversations(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Update conversation (admin/assignee only)
         * @param {DoctorUserConversationsV1ApiUpdateDoctorUserConversationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDoctorUserConversation(requestParameters: DoctorUserConversationsV1ApiUpdateDoctorUserConversationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDoctorUserConversation(requestParameters.id, requestParameters.updateDoctorUserConversationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createConversationDoctorAndUser operation in DoctorUserConversationsV1Api.
 * @export
 * @interface DoctorUserConversationsV1ApiCreateConversationDoctorAndUserRequest
 */
export interface DoctorUserConversationsV1ApiCreateConversationDoctorAndUserRequest {
    /**
     * 
     * @type {CreateDoctorUserConversationDto}
     * @memberof DoctorUserConversationsV1ApiCreateConversationDoctorAndUser
     */
    readonly createDoctorUserConversationDto: CreateDoctorUserConversationDto
}

/**
 * Request parameters for deleteDoctorUserConversation operation in DoctorUserConversationsV1Api.
 * @export
 * @interface DoctorUserConversationsV1ApiDeleteDoctorUserConversationRequest
 */
export interface DoctorUserConversationsV1ApiDeleteDoctorUserConversationRequest {
    /**
     * 
     * @type {string}
     * @memberof DoctorUserConversationsV1ApiDeleteDoctorUserConversation
     */
    readonly id: string
}

/**
 * Request parameters for getDoctorUserConversationById operation in DoctorUserConversationsV1Api.
 * @export
 * @interface DoctorUserConversationsV1ApiGetDoctorUserConversationByIdRequest
 */
export interface DoctorUserConversationsV1ApiGetDoctorUserConversationByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof DoctorUserConversationsV1ApiGetDoctorUserConversationById
     */
    readonly id: string
}

/**
 * Request parameters for getDoctorUserConversations operation in DoctorUserConversationsV1Api.
 * @export
 * @interface DoctorUserConversationsV1ApiGetDoctorUserConversationsRequest
 */
export interface DoctorUserConversationsV1ApiGetDoctorUserConversationsRequest {
    /**
     * 
     * @type {DoctorUserConversationCriteria}
     * @memberof DoctorUserConversationsV1ApiGetDoctorUserConversations
     */
    readonly criteria?: DoctorUserConversationCriteria

    /**
     * 
     * @type {Pageable}
     * @memberof DoctorUserConversationsV1ApiGetDoctorUserConversations
     */
    readonly pageable?: Pageable
}

/**
 * Request parameters for updateDoctorUserConversation operation in DoctorUserConversationsV1Api.
 * @export
 * @interface DoctorUserConversationsV1ApiUpdateDoctorUserConversationRequest
 */
export interface DoctorUserConversationsV1ApiUpdateDoctorUserConversationRequest {
    /**
     * 
     * @type {string}
     * @memberof DoctorUserConversationsV1ApiUpdateDoctorUserConversation
     */
    readonly id: string

    /**
     * 
     * @type {UpdateDoctorUserConversationDto}
     * @memberof DoctorUserConversationsV1ApiUpdateDoctorUserConversation
     */
    readonly updateDoctorUserConversationDto: UpdateDoctorUserConversationDto
}

/**
 * DoctorUserConversationsV1Api - object-oriented interface
 * @export
 * @class DoctorUserConversationsV1Api
 * @extends {BaseAPI}
 */
export class DoctorUserConversationsV1Api extends BaseAPI {
    /**
     * Create a conversation/question between doctor and user (questioner auto-filled from JWT)
     * @param {DoctorUserConversationsV1ApiCreateConversationDoctorAndUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoctorUserConversationsV1Api
     */
    public createConversationDoctorAndUser(requestParameters: DoctorUserConversationsV1ApiCreateConversationDoctorAndUserRequest, options?: RawAxiosRequestConfig) {
        return DoctorUserConversationsV1ApiFp(this.configuration).createConversationDoctorAndUser(requestParameters.createDoctorUserConversationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete conversation (admin only)
     * @param {DoctorUserConversationsV1ApiDeleteDoctorUserConversationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoctorUserConversationsV1Api
     */
    public deleteDoctorUserConversation(requestParameters: DoctorUserConversationsV1ApiDeleteDoctorUserConversationRequest, options?: RawAxiosRequestConfig) {
        return DoctorUserConversationsV1ApiFp(this.configuration).deleteDoctorUserConversation(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get conversation by ID with replies
     * @param {DoctorUserConversationsV1ApiGetDoctorUserConversationByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoctorUserConversationsV1Api
     */
    public getDoctorUserConversationById(requestParameters: DoctorUserConversationsV1ApiGetDoctorUserConversationByIdRequest, options?: RawAxiosRequestConfig) {
        return DoctorUserConversationsV1ApiFp(this.configuration).getDoctorUserConversationById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get doctor-user conversations by resource
     * @param {DoctorUserConversationsV1ApiGetDoctorUserConversationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoctorUserConversationsV1Api
     */
    public getDoctorUserConversations(requestParameters: DoctorUserConversationsV1ApiGetDoctorUserConversationsRequest = {}, options?: RawAxiosRequestConfig) {
        return DoctorUserConversationsV1ApiFp(this.configuration).getDoctorUserConversations(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update conversation (admin/assignee only)
     * @param {DoctorUserConversationsV1ApiUpdateDoctorUserConversationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoctorUserConversationsV1Api
     */
    public updateDoctorUserConversation(requestParameters: DoctorUserConversationsV1ApiUpdateDoctorUserConversationRequest, options?: RawAxiosRequestConfig) {
        return DoctorUserConversationsV1ApiFp(this.configuration).updateDoctorUserConversation(requestParameters.id, requestParameters.updateDoctorUserConversationDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnrollCourseV1Api - axios parameter creator
 * @export
 */
export const EnrollCourseV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Enroll a user into a specific course
         * @param {string} id Course ID
         * @param {UserInfoEnrollCourseDto} userInfoEnrollCourseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollUserInCourse: async (id: string, userInfoEnrollCourseDto: UserInfoEnrollCourseDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('enrollUserInCourse', 'id', id)
            // verify required parameter 'userInfoEnrollCourseDto' is not null or undefined
            assertParamExists('enrollUserInCourse', 'userInfoEnrollCourseDto', userInfoEnrollCourseDto)
            const localVarPath = `/api/v1/user/courses/{id}/enroll`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInfoEnrollCourseDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnrollCourseV1Api - functional programming interface
 * @export
 */
export const EnrollCourseV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnrollCourseV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Enroll a user into a specific course
         * @param {string} id Course ID
         * @param {UserInfoEnrollCourseDto} userInfoEnrollCourseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enrollUserInCourse(id: string, userInfoEnrollCourseDto: UserInfoEnrollCourseDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdWrapperDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enrollUserInCourse(id, userInfoEnrollCourseDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnrollCourseV1Api.enrollUserInCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EnrollCourseV1Api - factory interface
 * @export
 */
export const EnrollCourseV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnrollCourseV1ApiFp(configuration)
    return {
        /**
         * Enroll a user into a specific course
         * @param {EnrollCourseV1ApiEnrollUserInCourseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollUserInCourse(requestParameters: EnrollCourseV1ApiEnrollUserInCourseRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdWrapperDto> {
            return localVarFp.enrollUserInCourse(requestParameters.id, requestParameters.userInfoEnrollCourseDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for enrollUserInCourse operation in EnrollCourseV1Api.
 * @export
 * @interface EnrollCourseV1ApiEnrollUserInCourseRequest
 */
export interface EnrollCourseV1ApiEnrollUserInCourseRequest {
    /**
     * Course ID
     * @type {string}
     * @memberof EnrollCourseV1ApiEnrollUserInCourse
     */
    readonly id: string

    /**
     * 
     * @type {UserInfoEnrollCourseDto}
     * @memberof EnrollCourseV1ApiEnrollUserInCourse
     */
    readonly userInfoEnrollCourseDto: UserInfoEnrollCourseDto
}

/**
 * EnrollCourseV1Api - object-oriented interface
 * @export
 * @class EnrollCourseV1Api
 * @extends {BaseAPI}
 */
export class EnrollCourseV1Api extends BaseAPI {
    /**
     * Enroll a user into a specific course
     * @param {EnrollCourseV1ApiEnrollUserInCourseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnrollCourseV1Api
     */
    public enrollUserInCourse(requestParameters: EnrollCourseV1ApiEnrollUserInCourseRequest, options?: RawAxiosRequestConfig) {
        return EnrollCourseV1ApiFp(this.configuration).enrollUserInCourse(requestParameters.id, requestParameters.userInfoEnrollCourseDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MinioV1Api - axios parameter creator
 * @export
 */
export const MinioV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generate pre-signed URLs for upload
         * @param {GeneratePreSignedUrlDto} generatePreSignedUrlDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePreSignedUrls: async (generatePreSignedUrlDto: GeneratePreSignedUrlDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generatePreSignedUrlDto' is not null or undefined
            assertParamExists('generatePreSignedUrls', 'generatePreSignedUrlDto', generatePreSignedUrlDto)
            const localVarPath = `/api/v1/minio/presigned-urls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generatePreSignedUrlDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MinioV1Api - functional programming interface
 * @export
 */
export const MinioV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MinioV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Generate pre-signed URLs for upload
         * @param {GeneratePreSignedUrlDto} generatePreSignedUrlDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generatePreSignedUrls(generatePreSignedUrlDto: GeneratePreSignedUrlDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generatePreSignedUrls(generatePreSignedUrlDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MinioV1Api.generatePreSignedUrls']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MinioV1Api - factory interface
 * @export
 */
export const MinioV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MinioV1ApiFp(configuration)
    return {
        /**
         * Generate pre-signed URLs for upload
         * @param {MinioV1ApiGeneratePreSignedUrlsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePreSignedUrls(requestParameters: MinioV1ApiGeneratePreSignedUrlsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.generatePreSignedUrls(requestParameters.generatePreSignedUrlDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for generatePreSignedUrls operation in MinioV1Api.
 * @export
 * @interface MinioV1ApiGeneratePreSignedUrlsRequest
 */
export interface MinioV1ApiGeneratePreSignedUrlsRequest {
    /**
     * 
     * @type {GeneratePreSignedUrlDto}
     * @memberof MinioV1ApiGeneratePreSignedUrls
     */
    readonly generatePreSignedUrlDto: GeneratePreSignedUrlDto
}

/**
 * MinioV1Api - object-oriented interface
 * @export
 * @class MinioV1Api
 * @extends {BaseAPI}
 */
export class MinioV1Api extends BaseAPI {
    /**
     * Generate pre-signed URLs for upload
     * @param {MinioV1ApiGeneratePreSignedUrlsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MinioV1Api
     */
    public generatePreSignedUrls(requestParameters: MinioV1ApiGeneratePreSignedUrlsRequest, options?: RawAxiosRequestConfig) {
        return MinioV1ApiFp(this.configuration).generatePreSignedUrls(requestParameters.generatePreSignedUrlDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QuestionV1Api - axios parameter creator
 * @export
 */
export const QuestionV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new question for a test
         * @param {string} testId 
         * @param {CreateQuestionRequestDto} createQuestionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestion: async (testId: string, createQuestionRequestDto: CreateQuestionRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('createQuestion', 'testId', testId)
            // verify required parameter 'createQuestionRequestDto' is not null or undefined
            assertParamExists('createQuestion', 'createQuestionRequestDto', createQuestionRequestDto)
            const localVarPath = `/api/v1/tests/{testId}/questions`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createQuestionRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a question
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestion: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteQuestion', 'id', id)
            const localVarPath = `/api/v1/questions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a question by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getQuestionById', 'id', id)
            const localVarPath = `/api/v1/questions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all questions for a test
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionsByTestId: async (testId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getQuestionsByTestId', 'testId', testId)
            const localVarPath = `/api/v1/tests/{testId}/questions`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a question
         * @param {string} id 
         * @param {UpdateQuestionRequestDto} updateQuestionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestion: async (id: string, updateQuestionRequestDto: UpdateQuestionRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateQuestion', 'id', id)
            // verify required parameter 'updateQuestionRequestDto' is not null or undefined
            assertParamExists('updateQuestion', 'updateQuestionRequestDto', updateQuestionRequestDto)
            const localVarPath = `/api/v1/questions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateQuestionRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuestionV1Api - functional programming interface
 * @export
 */
export const QuestionV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuestionV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new question for a test
         * @param {string} testId 
         * @param {CreateQuestionRequestDto} createQuestionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQuestion(testId: string, createQuestionRequestDto: CreateQuestionRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdWrapperDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createQuestion(testId, createQuestionRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionV1Api.createQuestion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a question
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteQuestion(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteQuestion(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionV1Api.deleteQuestion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a question by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuestionById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuestionResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuestionById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionV1Api.getQuestionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all questions for a test
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuestionsByTestId(testId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuestionResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuestionsByTestId(testId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionV1Api.getQuestionsByTestId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a question
         * @param {string} id 
         * @param {UpdateQuestionRequestDto} updateQuestionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateQuestion(id: string, updateQuestionRequestDto: UpdateQuestionRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateQuestion(id, updateQuestionRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionV1Api.updateQuestion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QuestionV1Api - factory interface
 * @export
 */
export const QuestionV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuestionV1ApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new question for a test
         * @param {QuestionV1ApiCreateQuestionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestion(requestParameters: QuestionV1ApiCreateQuestionRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdWrapperDto> {
            return localVarFp.createQuestion(requestParameters.testId, requestParameters.createQuestionRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a question
         * @param {QuestionV1ApiDeleteQuestionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestion(requestParameters: QuestionV1ApiDeleteQuestionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteQuestion(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a question by ID
         * @param {QuestionV1ApiGetQuestionByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionById(requestParameters: QuestionV1ApiGetQuestionByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<QuestionResponseDto> {
            return localVarFp.getQuestionById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all questions for a test
         * @param {QuestionV1ApiGetQuestionsByTestIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionsByTestId(requestParameters: QuestionV1ApiGetQuestionsByTestIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<QuestionResponseDto>> {
            return localVarFp.getQuestionsByTestId(requestParameters.testId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a question
         * @param {QuestionV1ApiUpdateQuestionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestion(requestParameters: QuestionV1ApiUpdateQuestionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateQuestion(requestParameters.id, requestParameters.updateQuestionRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createQuestion operation in QuestionV1Api.
 * @export
 * @interface QuestionV1ApiCreateQuestionRequest
 */
export interface QuestionV1ApiCreateQuestionRequest {
    /**
     * 
     * @type {string}
     * @memberof QuestionV1ApiCreateQuestion
     */
    readonly testId: string

    /**
     * 
     * @type {CreateQuestionRequestDto}
     * @memberof QuestionV1ApiCreateQuestion
     */
    readonly createQuestionRequestDto: CreateQuestionRequestDto
}

/**
 * Request parameters for deleteQuestion operation in QuestionV1Api.
 * @export
 * @interface QuestionV1ApiDeleteQuestionRequest
 */
export interface QuestionV1ApiDeleteQuestionRequest {
    /**
     * 
     * @type {string}
     * @memberof QuestionV1ApiDeleteQuestion
     */
    readonly id: string
}

/**
 * Request parameters for getQuestionById operation in QuestionV1Api.
 * @export
 * @interface QuestionV1ApiGetQuestionByIdRequest
 */
export interface QuestionV1ApiGetQuestionByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof QuestionV1ApiGetQuestionById
     */
    readonly id: string
}

/**
 * Request parameters for getQuestionsByTestId operation in QuestionV1Api.
 * @export
 * @interface QuestionV1ApiGetQuestionsByTestIdRequest
 */
export interface QuestionV1ApiGetQuestionsByTestIdRequest {
    /**
     * 
     * @type {string}
     * @memberof QuestionV1ApiGetQuestionsByTestId
     */
    readonly testId: string
}

/**
 * Request parameters for updateQuestion operation in QuestionV1Api.
 * @export
 * @interface QuestionV1ApiUpdateQuestionRequest
 */
export interface QuestionV1ApiUpdateQuestionRequest {
    /**
     * 
     * @type {string}
     * @memberof QuestionV1ApiUpdateQuestion
     */
    readonly id: string

    /**
     * 
     * @type {UpdateQuestionRequestDto}
     * @memberof QuestionV1ApiUpdateQuestion
     */
    readonly updateQuestionRequestDto: UpdateQuestionRequestDto
}

/**
 * QuestionV1Api - object-oriented interface
 * @export
 * @class QuestionV1Api
 * @extends {BaseAPI}
 */
export class QuestionV1Api extends BaseAPI {
    /**
     * 
     * @summary Create a new question for a test
     * @param {QuestionV1ApiCreateQuestionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionV1Api
     */
    public createQuestion(requestParameters: QuestionV1ApiCreateQuestionRequest, options?: RawAxiosRequestConfig) {
        return QuestionV1ApiFp(this.configuration).createQuestion(requestParameters.testId, requestParameters.createQuestionRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a question
     * @param {QuestionV1ApiDeleteQuestionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionV1Api
     */
    public deleteQuestion(requestParameters: QuestionV1ApiDeleteQuestionRequest, options?: RawAxiosRequestConfig) {
        return QuestionV1ApiFp(this.configuration).deleteQuestion(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a question by ID
     * @param {QuestionV1ApiGetQuestionByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionV1Api
     */
    public getQuestionById(requestParameters: QuestionV1ApiGetQuestionByIdRequest, options?: RawAxiosRequestConfig) {
        return QuestionV1ApiFp(this.configuration).getQuestionById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all questions for a test
     * @param {QuestionV1ApiGetQuestionsByTestIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionV1Api
     */
    public getQuestionsByTestId(requestParameters: QuestionV1ApiGetQuestionsByTestIdRequest, options?: RawAxiosRequestConfig) {
        return QuestionV1ApiFp(this.configuration).getQuestionsByTestId(requestParameters.testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a question
     * @param {QuestionV1ApiUpdateQuestionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionV1Api
     */
    public updateQuestion(requestParameters: QuestionV1ApiUpdateQuestionRequest, options?: RawAxiosRequestConfig) {
        return QuestionV1ApiFp(this.configuration).updateQuestion(requestParameters.id, requestParameters.updateQuestionRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResourceV1Api - axios parameter creator
 * @export
 */
export const ResourceV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create resource(s) after uploading to MinIO
         * @param {CreateResourceRequest} createResourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResource: async (createResourceRequest: CreateResourceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createResourceRequest' is not null or undefined
            assertParamExists('createResource', 'createResourceRequest', createResourceRequest)
            const localVarPath = `/api/v1/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a resource by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResource: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteResource', 'id', id)
            const localVarPath = `/api/v1/resources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete resources by list of ids
         * @param {Array<string>} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResources: async (id: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteResources', 'id', id)
            const localVarPath = `/api/v1/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get resource by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getResourceById', 'id', id)
            const localVarPath = `/api/v1/resources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get resources by criteria
         * @param {ResourceCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResources: async (criteria?: ResourceCriteria, pageable?: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (criteria !== undefined) {
                for (const [key, value] of Object.entries(criteria)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing resource
         * @param {string} id 
         * @param {UpdateResourceRequestDto} [updateResourceRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResource: async (id: string, updateResourceRequestDto?: UpdateResourceRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateResource', 'id', id)
            const localVarPath = `/api/v1/resources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceV1Api - functional programming interface
 * @export
 */
export const ResourceV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create resource(s) after uploading to MinIO
         * @param {CreateResourceRequest} createResourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResource(createResourceRequest: CreateResourceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResource(createResourceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceV1Api.createResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a resource by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResource(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResource(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceV1Api.deleteResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete resources by list of ids
         * @param {Array<string>} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResources(id: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResources(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceV1Api.deleteResources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get resource by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourceById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDetailResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceV1Api.getResourceById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get resources by criteria
         * @param {ResourceCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResources(criteria?: ResourceCriteria, pageable?: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceResponsePaginatedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResources(criteria, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceV1Api.getResources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing resource
         * @param {string} id 
         * @param {UpdateResourceRequestDto} [updateResourceRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResource(id: string, updateResourceRequestDto?: UpdateResourceRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResource(id, updateResourceRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceV1Api.updateResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourceV1Api - factory interface
 * @export
 */
export const ResourceV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceV1ApiFp(configuration)
    return {
        /**
         * Create resource(s) after uploading to MinIO
         * @param {ResourceV1ApiCreateResourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResource(requestParameters: ResourceV1ApiCreateResourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.createResource(requestParameters.createResourceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a resource by ID
         * @param {ResourceV1ApiDeleteResourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResource(requestParameters: ResourceV1ApiDeleteResourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteResource(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete resources by list of ids
         * @param {ResourceV1ApiDeleteResourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResources(requestParameters: ResourceV1ApiDeleteResourcesRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteResources(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get resource by ID
         * @param {ResourceV1ApiGetResourceByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceById(requestParameters: ResourceV1ApiGetResourceByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResourceDetailResponseDto> {
            return localVarFp.getResourceById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get resources by criteria
         * @param {ResourceV1ApiGetResourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResources(requestParameters: ResourceV1ApiGetResourcesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ResourceResponsePaginatedDto> {
            return localVarFp.getResources(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing resource
         * @param {ResourceV1ApiUpdateResourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResource(requestParameters: ResourceV1ApiUpdateResourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateResource(requestParameters.id, requestParameters.updateResourceRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createResource operation in ResourceV1Api.
 * @export
 * @interface ResourceV1ApiCreateResourceRequest
 */
export interface ResourceV1ApiCreateResourceRequest {
    /**
     * 
     * @type {CreateResourceRequest}
     * @memberof ResourceV1ApiCreateResource
     */
    readonly createResourceRequest: CreateResourceRequest
}

/**
 * Request parameters for deleteResource operation in ResourceV1Api.
 * @export
 * @interface ResourceV1ApiDeleteResourceRequest
 */
export interface ResourceV1ApiDeleteResourceRequest {
    /**
     * 
     * @type {string}
     * @memberof ResourceV1ApiDeleteResource
     */
    readonly id: string
}

/**
 * Request parameters for deleteResources operation in ResourceV1Api.
 * @export
 * @interface ResourceV1ApiDeleteResourcesRequest
 */
export interface ResourceV1ApiDeleteResourcesRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceV1ApiDeleteResources
     */
    readonly id: Array<string>
}

/**
 * Request parameters for getResourceById operation in ResourceV1Api.
 * @export
 * @interface ResourceV1ApiGetResourceByIdRequest
 */
export interface ResourceV1ApiGetResourceByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof ResourceV1ApiGetResourceById
     */
    readonly id: string
}

/**
 * Request parameters for getResources operation in ResourceV1Api.
 * @export
 * @interface ResourceV1ApiGetResourcesRequest
 */
export interface ResourceV1ApiGetResourcesRequest {
    /**
     * 
     * @type {ResourceCriteria}
     * @memberof ResourceV1ApiGetResources
     */
    readonly criteria?: ResourceCriteria

    /**
     * 
     * @type {Pageable}
     * @memberof ResourceV1ApiGetResources
     */
    readonly pageable?: Pageable
}

/**
 * Request parameters for updateResource operation in ResourceV1Api.
 * @export
 * @interface ResourceV1ApiUpdateResourceRequest
 */
export interface ResourceV1ApiUpdateResourceRequest {
    /**
     * 
     * @type {string}
     * @memberof ResourceV1ApiUpdateResource
     */
    readonly id: string

    /**
     * 
     * @type {UpdateResourceRequestDto}
     * @memberof ResourceV1ApiUpdateResource
     */
    readonly updateResourceRequestDto?: UpdateResourceRequestDto
}

/**
 * ResourceV1Api - object-oriented interface
 * @export
 * @class ResourceV1Api
 * @extends {BaseAPI}
 */
export class ResourceV1Api extends BaseAPI {
    /**
     * Create resource(s) after uploading to MinIO
     * @param {ResourceV1ApiCreateResourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceV1Api
     */
    public createResource(requestParameters: ResourceV1ApiCreateResourceRequest, options?: RawAxiosRequestConfig) {
        return ResourceV1ApiFp(this.configuration).createResource(requestParameters.createResourceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a resource by ID
     * @param {ResourceV1ApiDeleteResourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceV1Api
     */
    public deleteResource(requestParameters: ResourceV1ApiDeleteResourceRequest, options?: RawAxiosRequestConfig) {
        return ResourceV1ApiFp(this.configuration).deleteResource(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete resources by list of ids
     * @param {ResourceV1ApiDeleteResourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceV1Api
     */
    public deleteResources(requestParameters: ResourceV1ApiDeleteResourcesRequest, options?: RawAxiosRequestConfig) {
        return ResourceV1ApiFp(this.configuration).deleteResources(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get resource by ID
     * @param {ResourceV1ApiGetResourceByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceV1Api
     */
    public getResourceById(requestParameters: ResourceV1ApiGetResourceByIdRequest, options?: RawAxiosRequestConfig) {
        return ResourceV1ApiFp(this.configuration).getResourceById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get resources by criteria
     * @param {ResourceV1ApiGetResourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceV1Api
     */
    public getResources(requestParameters: ResourceV1ApiGetResourcesRequest = {}, options?: RawAxiosRequestConfig) {
        return ResourceV1ApiFp(this.configuration).getResources(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing resource
     * @param {ResourceV1ApiUpdateResourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceV1Api
     */
    public updateResource(requestParameters: ResourceV1ApiUpdateResourceRequest, options?: RawAxiosRequestConfig) {
        return ResourceV1ApiFp(this.configuration).updateResource(requestParameters.id, requestParameters.updateResourceRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagV1Api - axios parameter creator
 * @export
 */
export const TagV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new tags
         * @param {CreateTagRequestDto} createTagRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag: async (createTagRequestDto: CreateTagRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTagRequestDto' is not null or undefined
            assertParamExists('createTag', 'createTagRequestDto', createTagRequestDto)
            const localVarPath = `/api/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTagRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete tags
         * @param {Array<string>} [tagIds] 
         * @param {Array<string>} [tagDetailIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (tagIds?: Array<string>, tagDetailIds?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (tagIds) {
                localVarQueryParameter['tagIds'] = tagIds;
            }

            if (tagDetailIds) {
                localVarQueryParameter['tagDetailIds'] = tagDetailIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get tags by parent and type
         * @param {Array<string>} [parentTag] 
         * @param {TagType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (parentTag?: Array<string>, type?: TagType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parentTag) {
                localVarQueryParameter['parentTag'] = parentTag;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagV1Api - functional programming interface
 * @export
 */
export const TagV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new tags
         * @param {CreateTagRequestDto} createTagRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTag(createTagRequestDto: CreateTagRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTag(createTagRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagV1Api.createTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete tags
         * @param {Array<string>} [tagIds] 
         * @param {Array<string>} [tagDetailIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(tagIds?: Array<string>, tagDetailIds?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(tagIds, tagDetailIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagV1Api.deleteTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get tags by parent and type
         * @param {Array<string>} [parentTag] 
         * @param {TagType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(parentTag?: Array<string>, type?: TagType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(parentTag, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagV1Api.getTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagV1Api - factory interface
 * @export
 */
export const TagV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagV1ApiFp(configuration)
    return {
        /**
         * Create new tags
         * @param {TagV1ApiCreateTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(requestParameters: TagV1ApiCreateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createTag(requestParameters.createTagRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete tags
         * @param {TagV1ApiDeleteTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(requestParameters: TagV1ApiDeleteTagRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTag(requestParameters.tagIds, requestParameters.tagDetailIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Get tags by parent and type
         * @param {TagV1ApiGetTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(requestParameters: TagV1ApiGetTagsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<TagResponseDto>> {
            return localVarFp.getTags(requestParameters.parentTag, requestParameters.type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTag operation in TagV1Api.
 * @export
 * @interface TagV1ApiCreateTagRequest
 */
export interface TagV1ApiCreateTagRequest {
    /**
     * 
     * @type {CreateTagRequestDto}
     * @memberof TagV1ApiCreateTag
     */
    readonly createTagRequestDto: CreateTagRequestDto
}

/**
 * Request parameters for deleteTag operation in TagV1Api.
 * @export
 * @interface TagV1ApiDeleteTagRequest
 */
export interface TagV1ApiDeleteTagRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof TagV1ApiDeleteTag
     */
    readonly tagIds?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof TagV1ApiDeleteTag
     */
    readonly tagDetailIds?: Array<string>
}

/**
 * Request parameters for getTags operation in TagV1Api.
 * @export
 * @interface TagV1ApiGetTagsRequest
 */
export interface TagV1ApiGetTagsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof TagV1ApiGetTags
     */
    readonly parentTag?: Array<string>

    /**
     * 
     * @type {TagType}
     * @memberof TagV1ApiGetTags
     */
    readonly type?: TagType
}

/**
 * TagV1Api - object-oriented interface
 * @export
 * @class TagV1Api
 * @extends {BaseAPI}
 */
export class TagV1Api extends BaseAPI {
    /**
     * Create new tags
     * @param {TagV1ApiCreateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagV1Api
     */
    public createTag(requestParameters: TagV1ApiCreateTagRequest, options?: RawAxiosRequestConfig) {
        return TagV1ApiFp(this.configuration).createTag(requestParameters.createTagRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete tags
     * @param {TagV1ApiDeleteTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagV1Api
     */
    public deleteTag(requestParameters: TagV1ApiDeleteTagRequest = {}, options?: RawAxiosRequestConfig) {
        return TagV1ApiFp(this.configuration).deleteTag(requestParameters.tagIds, requestParameters.tagDetailIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get tags by parent and type
     * @param {TagV1ApiGetTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagV1Api
     */
    public getTags(requestParameters: TagV1ApiGetTagsRequest = {}, options?: RawAxiosRequestConfig) {
        return TagV1ApiFp(this.configuration).getTags(requestParameters.parentTag, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TestV1Api - axios parameter creator
 * @export
 */
export const TestV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new test
         * @param {CreateTestRequestDto} createTestRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTest: async (createTestRequestDto: CreateTestRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTestRequestDto' is not null or undefined
            assertParamExists('createTest', 'createTestRequestDto', createTestRequestDto)
            const localVarPath = `/api/v1/tests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTestRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a test
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTest: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTest', 'id', id)
            const localVarPath = `/api/v1/tests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a test by course ID and type
         * @param {string} courseId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestByCourseIdAndType: async (courseId: string, type: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getTestByCourseIdAndType', 'courseId', courseId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getTestByCourseIdAndType', 'type', type)
            const localVarPath = `/api/v1/tests/by-course`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (courseId !== undefined) {
                localVarQueryParameter['courseId'] = courseId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a test by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTestById', 'id', id)
            const localVarPath = `/api/v1/tests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of tests
         * @param {string} [courseId] Filter by course ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTests: async (courseId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/tests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (courseId !== undefined) {
                localVarQueryParameter['courseId'] = courseId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a test
         * @param {string} id 
         * @param {UpdateTestRequestDto} updateTestRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTest: async (id: string, updateTestRequestDto: UpdateTestRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTest', 'id', id)
            // verify required parameter 'updateTestRequestDto' is not null or undefined
            assertParamExists('updateTest', 'updateTestRequestDto', updateTestRequestDto)
            const localVarPath = `/api/v1/tests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTestRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestV1Api - functional programming interface
 * @export
 */
export const TestV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new test
         * @param {CreateTestRequestDto} createTestRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTest(createTestRequestDto: CreateTestRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdWrapperDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTest(createTestRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestV1Api.createTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a test
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTest(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTest(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestV1Api.deleteTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a test by course ID and type
         * @param {string} courseId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestByCourseIdAndType(courseId: string, type: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestDetailResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestByCourseIdAndType(courseId, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestV1Api.getTestByCourseIdAndType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a test by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestDetailResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestV1Api.getTestById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of tests
         * @param {string} [courseId] Filter by course ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTests(courseId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TestResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTests(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestV1Api.getTests']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a test
         * @param {string} id 
         * @param {UpdateTestRequestDto} updateTestRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTest(id: string, updateTestRequestDto: UpdateTestRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTest(id, updateTestRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestV1Api.updateTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TestV1Api - factory interface
 * @export
 */
export const TestV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestV1ApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new test
         * @param {TestV1ApiCreateTestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTest(requestParameters: TestV1ApiCreateTestRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdWrapperDto> {
            return localVarFp.createTest(requestParameters.createTestRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a test
         * @param {TestV1ApiDeleteTestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTest(requestParameters: TestV1ApiDeleteTestRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTest(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a test by course ID and type
         * @param {TestV1ApiGetTestByCourseIdAndTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestByCourseIdAndType(requestParameters: TestV1ApiGetTestByCourseIdAndTypeRequest, options?: RawAxiosRequestConfig): AxiosPromise<TestDetailResponseDto> {
            return localVarFp.getTestByCourseIdAndType(requestParameters.courseId, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a test by ID
         * @param {TestV1ApiGetTestByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestById(requestParameters: TestV1ApiGetTestByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<TestDetailResponseDto> {
            return localVarFp.getTestById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of tests
         * @param {TestV1ApiGetTestsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTests(requestParameters: TestV1ApiGetTestsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<TestResponseDto>> {
            return localVarFp.getTests(requestParameters.courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a test
         * @param {TestV1ApiUpdateTestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTest(requestParameters: TestV1ApiUpdateTestRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateTest(requestParameters.id, requestParameters.updateTestRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTest operation in TestV1Api.
 * @export
 * @interface TestV1ApiCreateTestRequest
 */
export interface TestV1ApiCreateTestRequest {
    /**
     * 
     * @type {CreateTestRequestDto}
     * @memberof TestV1ApiCreateTest
     */
    readonly createTestRequestDto: CreateTestRequestDto
}

/**
 * Request parameters for deleteTest operation in TestV1Api.
 * @export
 * @interface TestV1ApiDeleteTestRequest
 */
export interface TestV1ApiDeleteTestRequest {
    /**
     * 
     * @type {string}
     * @memberof TestV1ApiDeleteTest
     */
    readonly id: string
}

/**
 * Request parameters for getTestByCourseIdAndType operation in TestV1Api.
 * @export
 * @interface TestV1ApiGetTestByCourseIdAndTypeRequest
 */
export interface TestV1ApiGetTestByCourseIdAndTypeRequest {
    /**
     * 
     * @type {string}
     * @memberof TestV1ApiGetTestByCourseIdAndType
     */
    readonly courseId: string

    /**
     * 
     * @type {string}
     * @memberof TestV1ApiGetTestByCourseIdAndType
     */
    readonly type: string
}

/**
 * Request parameters for getTestById operation in TestV1Api.
 * @export
 * @interface TestV1ApiGetTestByIdRequest
 */
export interface TestV1ApiGetTestByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof TestV1ApiGetTestById
     */
    readonly id: string
}

/**
 * Request parameters for getTests operation in TestV1Api.
 * @export
 * @interface TestV1ApiGetTestsRequest
 */
export interface TestV1ApiGetTestsRequest {
    /**
     * Filter by course ID
     * @type {string}
     * @memberof TestV1ApiGetTests
     */
    readonly courseId?: string
}

/**
 * Request parameters for updateTest operation in TestV1Api.
 * @export
 * @interface TestV1ApiUpdateTestRequest
 */
export interface TestV1ApiUpdateTestRequest {
    /**
     * 
     * @type {string}
     * @memberof TestV1ApiUpdateTest
     */
    readonly id: string

    /**
     * 
     * @type {UpdateTestRequestDto}
     * @memberof TestV1ApiUpdateTest
     */
    readonly updateTestRequestDto: UpdateTestRequestDto
}

/**
 * TestV1Api - object-oriented interface
 * @export
 * @class TestV1Api
 * @extends {BaseAPI}
 */
export class TestV1Api extends BaseAPI {
    /**
     * 
     * @summary Create a new test
     * @param {TestV1ApiCreateTestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestV1Api
     */
    public createTest(requestParameters: TestV1ApiCreateTestRequest, options?: RawAxiosRequestConfig) {
        return TestV1ApiFp(this.configuration).createTest(requestParameters.createTestRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a test
     * @param {TestV1ApiDeleteTestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestV1Api
     */
    public deleteTest(requestParameters: TestV1ApiDeleteTestRequest, options?: RawAxiosRequestConfig) {
        return TestV1ApiFp(this.configuration).deleteTest(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a test by course ID and type
     * @param {TestV1ApiGetTestByCourseIdAndTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestV1Api
     */
    public getTestByCourseIdAndType(requestParameters: TestV1ApiGetTestByCourseIdAndTypeRequest, options?: RawAxiosRequestConfig) {
        return TestV1ApiFp(this.configuration).getTestByCourseIdAndType(requestParameters.courseId, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a test by ID
     * @param {TestV1ApiGetTestByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestV1Api
     */
    public getTestById(requestParameters: TestV1ApiGetTestByIdRequest, options?: RawAxiosRequestConfig) {
        return TestV1ApiFp(this.configuration).getTestById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of tests
     * @param {TestV1ApiGetTestsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestV1Api
     */
    public getTests(requestParameters: TestV1ApiGetTestsRequest = {}, options?: RawAxiosRequestConfig) {
        return TestV1ApiFp(this.configuration).getTests(requestParameters.courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a test
     * @param {TestV1ApiUpdateTestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestV1Api
     */
    public updateTest(requestParameters: TestV1ApiUpdateTestRequest, options?: RawAxiosRequestConfig) {
        return TestV1ApiFp(this.configuration).updateTest(requestParameters.id, requestParameters.updateTestRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserCourseLecturesV1Api - axios parameter creator
 * @export
 */
export const UserCourseLecturesV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get lectures for a course the user has enrolled in
         * @param {string} courseId 
         * @param {string} userInfoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCourseLectures: async (courseId: string, userInfoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getUserCourseLectures', 'courseId', courseId)
            // verify required parameter 'userInfoId' is not null or undefined
            assertParamExists('getUserCourseLectures', 'userInfoId', userInfoId)
            const localVarPath = `/api/v1/user/courses/{courseId}/lectures`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userInfoId !== undefined) {
                localVarQueryParameter['userInfoId'] = userInfoId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Record lecture progress
         * @param {string} id User progress course section ID
         * @param {RecordDataUserCourseSectionDto} recordDataUserCourseSectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordCourseSectionData: async (id: string, recordDataUserCourseSectionDto: RecordDataUserCourseSectionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('recordCourseSectionData', 'id', id)
            // verify required parameter 'recordDataUserCourseSectionDto' is not null or undefined
            assertParamExists('recordCourseSectionData', 'recordDataUserCourseSectionDto', recordDataUserCourseSectionDto)
            const localVarPath = `/api/v1/user/courses/lectures/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordDataUserCourseSectionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserCourseLecturesV1Api - functional programming interface
 * @export
 */
export const UserCourseLecturesV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserCourseLecturesV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Get lectures for a course the user has enrolled in
         * @param {string} courseId 
         * @param {string} userInfoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCourseLectures(courseId: string, userInfoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LectureAndTestDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCourseLectures(courseId, userInfoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserCourseLecturesV1Api.getUserCourseLectures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Record lecture progress
         * @param {string} id User progress course section ID
         * @param {RecordDataUserCourseSectionDto} recordDataUserCourseSectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordCourseSectionData(id: string, recordDataUserCourseSectionDto: RecordDataUserCourseSectionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdWrapperDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordCourseSectionData(id, recordDataUserCourseSectionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserCourseLecturesV1Api.recordCourseSectionData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserCourseLecturesV1Api - factory interface
 * @export
 */
export const UserCourseLecturesV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserCourseLecturesV1ApiFp(configuration)
    return {
        /**
         * Get lectures for a course the user has enrolled in
         * @param {UserCourseLecturesV1ApiGetUserCourseLecturesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCourseLectures(requestParameters: UserCourseLecturesV1ApiGetUserCourseLecturesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<LectureAndTestDto>> {
            return localVarFp.getUserCourseLectures(requestParameters.courseId, requestParameters.userInfoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Record lecture progress
         * @param {UserCourseLecturesV1ApiRecordCourseSectionDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordCourseSectionData(requestParameters: UserCourseLecturesV1ApiRecordCourseSectionDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdWrapperDto> {
            return localVarFp.recordCourseSectionData(requestParameters.id, requestParameters.recordDataUserCourseSectionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getUserCourseLectures operation in UserCourseLecturesV1Api.
 * @export
 * @interface UserCourseLecturesV1ApiGetUserCourseLecturesRequest
 */
export interface UserCourseLecturesV1ApiGetUserCourseLecturesRequest {
    /**
     * 
     * @type {string}
     * @memberof UserCourseLecturesV1ApiGetUserCourseLectures
     */
    readonly courseId: string

    /**
     * 
     * @type {string}
     * @memberof UserCourseLecturesV1ApiGetUserCourseLectures
     */
    readonly userInfoId: string
}

/**
 * Request parameters for recordCourseSectionData operation in UserCourseLecturesV1Api.
 * @export
 * @interface UserCourseLecturesV1ApiRecordCourseSectionDataRequest
 */
export interface UserCourseLecturesV1ApiRecordCourseSectionDataRequest {
    /**
     * User progress course section ID
     * @type {string}
     * @memberof UserCourseLecturesV1ApiRecordCourseSectionData
     */
    readonly id: string

    /**
     * 
     * @type {RecordDataUserCourseSectionDto}
     * @memberof UserCourseLecturesV1ApiRecordCourseSectionData
     */
    readonly recordDataUserCourseSectionDto: RecordDataUserCourseSectionDto
}

/**
 * UserCourseLecturesV1Api - object-oriented interface
 * @export
 * @class UserCourseLecturesV1Api
 * @extends {BaseAPI}
 */
export class UserCourseLecturesV1Api extends BaseAPI {
    /**
     * Get lectures for a course the user has enrolled in
     * @param {UserCourseLecturesV1ApiGetUserCourseLecturesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserCourseLecturesV1Api
     */
    public getUserCourseLectures(requestParameters: UserCourseLecturesV1ApiGetUserCourseLecturesRequest, options?: RawAxiosRequestConfig) {
        return UserCourseLecturesV1ApiFp(this.configuration).getUserCourseLectures(requestParameters.courseId, requestParameters.userInfoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Record lecture progress
     * @param {UserCourseLecturesV1ApiRecordCourseSectionDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserCourseLecturesV1Api
     */
    public recordCourseSectionData(requestParameters: UserCourseLecturesV1ApiRecordCourseSectionDataRequest, options?: RawAxiosRequestConfig) {
        return UserCourseLecturesV1ApiFp(this.configuration).recordCourseSectionData(requestParameters.id, requestParameters.recordDataUserCourseSectionDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserCourseV1Api - axios parameter creator
 * @export
 */
export const UserCourseV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get progress of courses for user
         * @param {string} userInfoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgressCoursesUser: async (userInfoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userInfoId' is not null or undefined
            assertParamExists('getProgressCoursesUser', 'userInfoId', userInfoId)
            const localVarPath = `/api/v1/user/courses/progress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userInfoId !== undefined) {
                localVarQueryParameter['userInfoId'] = userInfoId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get status progress of course for user
         * @param {string} userInfoId 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusProgressCourseUser: async (userInfoId: string, courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userInfoId' is not null or undefined
            assertParamExists('getStatusProgressCourseUser', 'userInfoId', userInfoId)
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getStatusProgressCourseUser', 'courseId', courseId)
            const localVarPath = `/api/v1/user/courses/progress/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userInfoId !== undefined) {
                localVarQueryParameter['userInfoId'] = userInfoId;
            }

            if (courseId !== undefined) {
                localVarQueryParameter['courseId'] = courseId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user course by ID
         * @param {string} id 
         * @param {string} userInfoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCourseById: async (id: string, userInfoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserCourseById', 'id', id)
            // verify required parameter 'userInfoId' is not null or undefined
            assertParamExists('getUserCourseById', 'userInfoId', userInfoId)
            const localVarPath = `/api/v1/user/courses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userInfoId !== undefined) {
                localVarQueryParameter['userInfoId'] = userInfoId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all courses for user screen
         * @param {CourseCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCourses: async (criteria?: CourseCriteria, pageable?: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (criteria !== undefined) {
                for (const [key, value] of Object.entries(criteria)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserCourseV1Api - functional programming interface
 * @export
 */
export const UserCourseV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserCourseV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Get progress of courses for user
         * @param {string} userInfoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgressCoursesUser(userInfoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserProgressCourseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgressCoursesUser(userInfoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserCourseV1Api.getProgressCoursesUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get status progress of course for user
         * @param {string} userInfoId 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusProgressCourseUser(userInfoId: string, courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusUserProgressCourseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusProgressCourseUser(userInfoId, courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserCourseV1Api.getStatusProgressCourseUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user course by ID
         * @param {string} id 
         * @param {string} userInfoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCourseById(id: string, userInfoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDetailCourseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCourseById(id, userInfoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserCourseV1Api.getUserCourseById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all courses for user screen
         * @param {CourseCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCourses(criteria?: CourseCriteria, pageable?: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCourseResponsePaginatedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCourses(criteria, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserCourseV1Api.getUserCourses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserCourseV1Api - factory interface
 * @export
 */
export const UserCourseV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserCourseV1ApiFp(configuration)
    return {
        /**
         * Get progress of courses for user
         * @param {UserCourseV1ApiGetProgressCoursesUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgressCoursesUser(requestParameters: UserCourseV1ApiGetProgressCoursesUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserProgressCourseDto>> {
            return localVarFp.getProgressCoursesUser(requestParameters.userInfoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get status progress of course for user
         * @param {UserCourseV1ApiGetStatusProgressCourseUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusProgressCourseUser(requestParameters: UserCourseV1ApiGetStatusProgressCourseUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<StatusUserProgressCourseDto> {
            return localVarFp.getStatusProgressCourseUser(requestParameters.userInfoId, requestParameters.courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user course by ID
         * @param {UserCourseV1ApiGetUserCourseByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCourseById(requestParameters: UserCourseV1ApiGetUserCourseByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserResponseDetailCourseDto> {
            return localVarFp.getUserCourseById(requestParameters.id, requestParameters.userInfoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all courses for user screen
         * @param {UserCourseV1ApiGetUserCoursesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCourses(requestParameters: UserCourseV1ApiGetUserCoursesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<UserCourseResponsePaginatedDto> {
            return localVarFp.getUserCourses(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getProgressCoursesUser operation in UserCourseV1Api.
 * @export
 * @interface UserCourseV1ApiGetProgressCoursesUserRequest
 */
export interface UserCourseV1ApiGetProgressCoursesUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserCourseV1ApiGetProgressCoursesUser
     */
    readonly userInfoId: string
}

/**
 * Request parameters for getStatusProgressCourseUser operation in UserCourseV1Api.
 * @export
 * @interface UserCourseV1ApiGetStatusProgressCourseUserRequest
 */
export interface UserCourseV1ApiGetStatusProgressCourseUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserCourseV1ApiGetStatusProgressCourseUser
     */
    readonly userInfoId: string

    /**
     * 
     * @type {string}
     * @memberof UserCourseV1ApiGetStatusProgressCourseUser
     */
    readonly courseId: string
}

/**
 * Request parameters for getUserCourseById operation in UserCourseV1Api.
 * @export
 * @interface UserCourseV1ApiGetUserCourseByIdRequest
 */
export interface UserCourseV1ApiGetUserCourseByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof UserCourseV1ApiGetUserCourseById
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof UserCourseV1ApiGetUserCourseById
     */
    readonly userInfoId: string
}

/**
 * Request parameters for getUserCourses operation in UserCourseV1Api.
 * @export
 * @interface UserCourseV1ApiGetUserCoursesRequest
 */
export interface UserCourseV1ApiGetUserCoursesRequest {
    /**
     * 
     * @type {CourseCriteria}
     * @memberof UserCourseV1ApiGetUserCourses
     */
    readonly criteria?: CourseCriteria

    /**
     * 
     * @type {Pageable}
     * @memberof UserCourseV1ApiGetUserCourses
     */
    readonly pageable?: Pageable
}

/**
 * UserCourseV1Api - object-oriented interface
 * @export
 * @class UserCourseV1Api
 * @extends {BaseAPI}
 */
export class UserCourseV1Api extends BaseAPI {
    /**
     * Get progress of courses for user
     * @param {UserCourseV1ApiGetProgressCoursesUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserCourseV1Api
     */
    public getProgressCoursesUser(requestParameters: UserCourseV1ApiGetProgressCoursesUserRequest, options?: RawAxiosRequestConfig) {
        return UserCourseV1ApiFp(this.configuration).getProgressCoursesUser(requestParameters.userInfoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get status progress of course for user
     * @param {UserCourseV1ApiGetStatusProgressCourseUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserCourseV1Api
     */
    public getStatusProgressCourseUser(requestParameters: UserCourseV1ApiGetStatusProgressCourseUserRequest, options?: RawAxiosRequestConfig) {
        return UserCourseV1ApiFp(this.configuration).getStatusProgressCourseUser(requestParameters.userInfoId, requestParameters.courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user course by ID
     * @param {UserCourseV1ApiGetUserCourseByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserCourseV1Api
     */
    public getUserCourseById(requestParameters: UserCourseV1ApiGetUserCourseByIdRequest, options?: RawAxiosRequestConfig) {
        return UserCourseV1ApiFp(this.configuration).getUserCourseById(requestParameters.id, requestParameters.userInfoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all courses for user screen
     * @param {UserCourseV1ApiGetUserCoursesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserCourseV1Api
     */
    public getUserCourses(requestParameters: UserCourseV1ApiGetUserCoursesRequest = {}, options?: RawAxiosRequestConfig) {
        return UserCourseV1ApiFp(this.configuration).getUserCourses(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserResourceHistoryV1Api - axios parameter creator
 * @export
 */
export const UserResourceHistoryV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a resource accessed by user
         * @param {string} userInfoId 
         * @param {string} resourceId 
         * @param {UserResourceType} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserResource: async (userInfoId: string, resourceId: string, type: UserResourceType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userInfoId' is not null or undefined
            assertParamExists('createUserResource', 'userInfoId', userInfoId)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('createUserResource', 'resourceId', resourceId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createUserResource', 'type', type)
            const localVarPath = `/api/v1/user/resources-accessed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (userInfoId !== undefined) { 
                localVarFormParams.append('userInfoId', userInfoId as any);
            }
    
            if (resourceId !== undefined) { 
                localVarFormParams.append('resourceId', resourceId as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.append('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get resources accessed by user
         * @param {UserResourceHistoryCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcesAccessedByUserInfoIdAndType: async (criteria?: UserResourceHistoryCriteria, pageable?: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/resources-accessed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (criteria !== undefined) {
                for (const [key, value] of Object.entries(criteria)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserResourceHistoryV1Api - functional programming interface
 * @export
 */
export const UserResourceHistoryV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserResourceHistoryV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a resource accessed by user
         * @param {string} userInfoId 
         * @param {string} resourceId 
         * @param {UserResourceType} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserResource(userInfoId: string, resourceId: string, type: UserResourceType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdWrapperDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserResource(userInfoId, resourceId, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserResourceHistoryV1Api.createUserResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get resources accessed by user
         * @param {UserResourceHistoryCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourcesAccessedByUserInfoIdAndType(criteria?: UserResourceHistoryCriteria, pageable?: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResourcesAccessedResponsePaginatedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourcesAccessedByUserInfoIdAndType(criteria, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserResourceHistoryV1Api.getResourcesAccessedByUserInfoIdAndType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserResourceHistoryV1Api - factory interface
 * @export
 */
export const UserResourceHistoryV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserResourceHistoryV1ApiFp(configuration)
    return {
        /**
         * Create a resource accessed by user
         * @param {UserResourceHistoryV1ApiCreateUserResourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserResource(requestParameters: UserResourceHistoryV1ApiCreateUserResourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdWrapperDto> {
            return localVarFp.createUserResource(requestParameters.userInfoId, requestParameters.resourceId, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * Get resources accessed by user
         * @param {UserResourceHistoryV1ApiGetResourcesAccessedByUserInfoIdAndTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcesAccessedByUserInfoIdAndType(requestParameters: UserResourceHistoryV1ApiGetResourcesAccessedByUserInfoIdAndTypeRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<UserResourcesAccessedResponsePaginatedDto> {
            return localVarFp.getResourcesAccessedByUserInfoIdAndType(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createUserResource operation in UserResourceHistoryV1Api.
 * @export
 * @interface UserResourceHistoryV1ApiCreateUserResourceRequest
 */
export interface UserResourceHistoryV1ApiCreateUserResourceRequest {
    /**
     * 
     * @type {string}
     * @memberof UserResourceHistoryV1ApiCreateUserResource
     */
    readonly userInfoId: string

    /**
     * 
     * @type {string}
     * @memberof UserResourceHistoryV1ApiCreateUserResource
     */
    readonly resourceId: string

    /**
     * 
     * @type {UserResourceType}
     * @memberof UserResourceHistoryV1ApiCreateUserResource
     */
    readonly type: UserResourceType
}

/**
 * Request parameters for getResourcesAccessedByUserInfoIdAndType operation in UserResourceHistoryV1Api.
 * @export
 * @interface UserResourceHistoryV1ApiGetResourcesAccessedByUserInfoIdAndTypeRequest
 */
export interface UserResourceHistoryV1ApiGetResourcesAccessedByUserInfoIdAndTypeRequest {
    /**
     * 
     * @type {UserResourceHistoryCriteria}
     * @memberof UserResourceHistoryV1ApiGetResourcesAccessedByUserInfoIdAndType
     */
    readonly criteria?: UserResourceHistoryCriteria

    /**
     * 
     * @type {Pageable}
     * @memberof UserResourceHistoryV1ApiGetResourcesAccessedByUserInfoIdAndType
     */
    readonly pageable?: Pageable
}

/**
 * UserResourceHistoryV1Api - object-oriented interface
 * @export
 * @class UserResourceHistoryV1Api
 * @extends {BaseAPI}
 */
export class UserResourceHistoryV1Api extends BaseAPI {
    /**
     * Create a resource accessed by user
     * @param {UserResourceHistoryV1ApiCreateUserResourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserResourceHistoryV1Api
     */
    public createUserResource(requestParameters: UserResourceHistoryV1ApiCreateUserResourceRequest, options?: RawAxiosRequestConfig) {
        return UserResourceHistoryV1ApiFp(this.configuration).createUserResource(requestParameters.userInfoId, requestParameters.resourceId, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get resources accessed by user
     * @param {UserResourceHistoryV1ApiGetResourcesAccessedByUserInfoIdAndTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserResourceHistoryV1Api
     */
    public getResourcesAccessedByUserInfoIdAndType(requestParameters: UserResourceHistoryV1ApiGetResourcesAccessedByUserInfoIdAndTypeRequest = {}, options?: RawAxiosRequestConfig) {
        return UserResourceHistoryV1ApiFp(this.configuration).getResourcesAccessedByUserInfoIdAndType(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserResourceV1Api - axios parameter creator
 * @export
 */
export const UserResourceV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get resource by ID for students/users
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserResourceById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserResourceById', 'id', id)
            const localVarPath = `/api/v1/user/resources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list resources for students/users
         * @param {ResourceCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserResources: async (criteria?: ResourceCriteria, pageable?: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (criteria !== undefined) {
                for (const [key, value] of Object.entries(criteria)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserResourceV1Api - functional programming interface
 * @export
 */
export const UserResourceV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserResourceV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Get resource by ID for students/users
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserResourceById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResourceDetailResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserResourceById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserResourceV1Api.getUserResourceById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list resources for students/users
         * @param {ResourceCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserResources(criteria?: ResourceCriteria, pageable?: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResourceResponsePaginatedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserResources(criteria, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserResourceV1Api.getUserResources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserResourceV1Api - factory interface
 * @export
 */
export const UserResourceV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserResourceV1ApiFp(configuration)
    return {
        /**
         * Get resource by ID for students/users
         * @param {UserResourceV1ApiGetUserResourceByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserResourceById(requestParameters: UserResourceV1ApiGetUserResourceByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserResourceDetailResponseDto> {
            return localVarFp.getUserResourceById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list resources for students/users
         * @param {UserResourceV1ApiGetUserResourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserResources(requestParameters: UserResourceV1ApiGetUserResourcesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<UserResourceResponsePaginatedDto> {
            return localVarFp.getUserResources(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getUserResourceById operation in UserResourceV1Api.
 * @export
 * @interface UserResourceV1ApiGetUserResourceByIdRequest
 */
export interface UserResourceV1ApiGetUserResourceByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof UserResourceV1ApiGetUserResourceById
     */
    readonly id: string
}

/**
 * Request parameters for getUserResources operation in UserResourceV1Api.
 * @export
 * @interface UserResourceV1ApiGetUserResourcesRequest
 */
export interface UserResourceV1ApiGetUserResourcesRequest {
    /**
     * 
     * @type {ResourceCriteria}
     * @memberof UserResourceV1ApiGetUserResources
     */
    readonly criteria?: ResourceCriteria

    /**
     * 
     * @type {Pageable}
     * @memberof UserResourceV1ApiGetUserResources
     */
    readonly pageable?: Pageable
}

/**
 * UserResourceV1Api - object-oriented interface
 * @export
 * @class UserResourceV1Api
 * @extends {BaseAPI}
 */
export class UserResourceV1Api extends BaseAPI {
    /**
     * Get resource by ID for students/users
     * @param {UserResourceV1ApiGetUserResourceByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserResourceV1Api
     */
    public getUserResourceById(requestParameters: UserResourceV1ApiGetUserResourceByIdRequest, options?: RawAxiosRequestConfig) {
        return UserResourceV1ApiFp(this.configuration).getUserResourceById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list resources for students/users
     * @param {UserResourceV1ApiGetUserResourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserResourceV1Api
     */
    public getUserResources(requestParameters: UserResourceV1ApiGetUserResourcesRequest = {}, options?: RawAxiosRequestConfig) {
        return UserResourceV1ApiFp(this.configuration).getUserResources(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserV1Api - axios parameter creator
 * @export
 */
export const UserV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new user
         * @param {CreateUserRequestDto} createUserRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserRequestDto: CreateUserRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserRequestDto' is not null or undefined
            assertParamExists('createUser', 'createUserRequestDto', createUserRequestDto)
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete user
         * @param {string} id 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, password: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('deleteUser', 'password', password)
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserById', 'id', id)
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get users by criteria
         * @param {UserInfoCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (criteria?: UserInfoCriteria, pageable?: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (criteria !== undefined) {
                for (const [key, value] of Object.entries(criteria)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a new user
         * @param {InviteUserRequestDto} inviteUserRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUser: async (inviteUserRequestDto: InviteUserRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteUserRequestDto' is not null or undefined
            assertParamExists('inviteUser', 'inviteUserRequestDto', inviteUserRequestDto)
            const localVarPath = `/api/v1/users/invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteUserRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user
         * @param {string} id 
         * @param {UpdateUserRequestDto} updateUserRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: string, updateUserRequestDto: UpdateUserRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            // verify required parameter 'updateUserRequestDto' is not null or undefined
            assertParamExists('updateUser', 'updateUserRequestDto', updateUserRequestDto)
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserV1Api - functional programming interface
 * @export
 */
export const UserV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new user
         * @param {CreateUserRequestDto} createUserRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserRequestDto: CreateUserRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdWrapperDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserV1Api.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete user
         * @param {string} id 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, password: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, password, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserV1Api.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUserInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUserInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserV1Api.getCurrentUserInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserV1Api.getUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserV1Api.getUserInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get users by criteria
         * @param {UserInfoCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(criteria?: UserInfoCriteria, pageable?: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponsePaginatedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(criteria, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserV1Api.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invite a new user
         * @param {InviteUserRequestDto} inviteUserRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteUser(inviteUserRequestDto: InviteUserRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdWrapperDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteUser(inviteUserRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserV1Api.inviteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user
         * @param {string} id 
         * @param {UpdateUserRequestDto} updateUserRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: string, updateUserRequestDto: UpdateUserRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, updateUserRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserV1Api.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserV1Api - factory interface
 * @export
 */
export const UserV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserV1ApiFp(configuration)
    return {
        /**
         * Create a new user
         * @param {UserV1ApiCreateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(requestParameters: UserV1ApiCreateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdWrapperDto> {
            return localVarFp.createUser(requestParameters.createUserRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete user
         * @param {UserV1ApiDeleteUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(requestParameters: UserV1ApiDeleteUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(requestParameters.id, requestParameters.password, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserInfo(options?: RawAxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.getCurrentUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Get user by ID
         * @param {UserV1ApiGetUserByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(requestParameters: UserV1ApiGetUserByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.getUserById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(options?: RawAxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.getUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Get users by criteria
         * @param {UserV1ApiGetUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(requestParameters: UserV1ApiGetUsersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<UserResponsePaginatedDto> {
            return localVarFp.getUsers(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a new user
         * @param {UserV1ApiInviteUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUser(requestParameters: UserV1ApiInviteUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdWrapperDto> {
            return localVarFp.inviteUser(requestParameters.inviteUserRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user
         * @param {UserV1ApiUpdateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestParameters: UserV1ApiUpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateUser(requestParameters.id, requestParameters.updateUserRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createUser operation in UserV1Api.
 * @export
 * @interface UserV1ApiCreateUserRequest
 */
export interface UserV1ApiCreateUserRequest {
    /**
     * 
     * @type {CreateUserRequestDto}
     * @memberof UserV1ApiCreateUser
     */
    readonly createUserRequestDto: CreateUserRequestDto
}

/**
 * Request parameters for deleteUser operation in UserV1Api.
 * @export
 * @interface UserV1ApiDeleteUserRequest
 */
export interface UserV1ApiDeleteUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserV1ApiDeleteUser
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof UserV1ApiDeleteUser
     */
    readonly password: string
}

/**
 * Request parameters for getUserById operation in UserV1Api.
 * @export
 * @interface UserV1ApiGetUserByIdRequest
 */
export interface UserV1ApiGetUserByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof UserV1ApiGetUserById
     */
    readonly id: string
}

/**
 * Request parameters for getUsers operation in UserV1Api.
 * @export
 * @interface UserV1ApiGetUsersRequest
 */
export interface UserV1ApiGetUsersRequest {
    /**
     * 
     * @type {UserInfoCriteria}
     * @memberof UserV1ApiGetUsers
     */
    readonly criteria?: UserInfoCriteria

    /**
     * 
     * @type {Pageable}
     * @memberof UserV1ApiGetUsers
     */
    readonly pageable?: Pageable
}

/**
 * Request parameters for inviteUser operation in UserV1Api.
 * @export
 * @interface UserV1ApiInviteUserRequest
 */
export interface UserV1ApiInviteUserRequest {
    /**
     * 
     * @type {InviteUserRequestDto}
     * @memberof UserV1ApiInviteUser
     */
    readonly inviteUserRequestDto: InviteUserRequestDto
}

/**
 * Request parameters for updateUser operation in UserV1Api.
 * @export
 * @interface UserV1ApiUpdateUserRequest
 */
export interface UserV1ApiUpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserV1ApiUpdateUser
     */
    readonly id: string

    /**
     * 
     * @type {UpdateUserRequestDto}
     * @memberof UserV1ApiUpdateUser
     */
    readonly updateUserRequestDto: UpdateUserRequestDto
}

/**
 * UserV1Api - object-oriented interface
 * @export
 * @class UserV1Api
 * @extends {BaseAPI}
 */
export class UserV1Api extends BaseAPI {
    /**
     * Create a new user
     * @param {UserV1ApiCreateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserV1Api
     */
    public createUser(requestParameters: UserV1ApiCreateUserRequest, options?: RawAxiosRequestConfig) {
        return UserV1ApiFp(this.configuration).createUser(requestParameters.createUserRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete user
     * @param {UserV1ApiDeleteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserV1Api
     */
    public deleteUser(requestParameters: UserV1ApiDeleteUserRequest, options?: RawAxiosRequestConfig) {
        return UserV1ApiFp(this.configuration).deleteUser(requestParameters.id, requestParameters.password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserV1Api
     */
    public getCurrentUserInfo(options?: RawAxiosRequestConfig) {
        return UserV1ApiFp(this.configuration).getCurrentUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user by ID
     * @param {UserV1ApiGetUserByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserV1Api
     */
    public getUserById(requestParameters: UserV1ApiGetUserByIdRequest, options?: RawAxiosRequestConfig) {
        return UserV1ApiFp(this.configuration).getUserById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserV1Api
     */
    public getUserInfo(options?: RawAxiosRequestConfig) {
        return UserV1ApiFp(this.configuration).getUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get users by criteria
     * @param {UserV1ApiGetUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserV1Api
     */
    public getUsers(requestParameters: UserV1ApiGetUsersRequest = {}, options?: RawAxiosRequestConfig) {
        return UserV1ApiFp(this.configuration).getUsers(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a new user
     * @param {UserV1ApiInviteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserV1Api
     */
    public inviteUser(requestParameters: UserV1ApiInviteUserRequest, options?: RawAxiosRequestConfig) {
        return UserV1ApiFp(this.configuration).inviteUser(requestParameters.inviteUserRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user
     * @param {UserV1ApiUpdateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserV1Api
     */
    public updateUser(requestParameters: UserV1ApiUpdateUserRequest, options?: RawAxiosRequestConfig) {
        return UserV1ApiFp(this.configuration).updateUser(requestParameters.id, requestParameters.updateUserRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhookV1Api - axios parameter creator
 * @export
 */
export const WebhookV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Receive Keycloak webhook events
         * @param {WebhookKeycloakRequestDto} webhookKeycloakRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeKeycloakEvent: async (webhookKeycloakRequestDto: WebhookKeycloakRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookKeycloakRequestDto' is not null or undefined
            assertParamExists('subscribeKeycloakEvent', 'webhookKeycloakRequestDto', webhookKeycloakRequestDto)
            const localVarPath = `/api/v1/webhooks/keycloak`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookKeycloakRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receive MinIO webhook events
         * @param {WebhookMinIOEventDto} webhookMinIOEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeMinioEvent: async (webhookMinIOEventDto: WebhookMinIOEventDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookMinIOEventDto' is not null or undefined
            assertParamExists('subscribeMinioEvent', 'webhookMinIOEventDto', webhookMinIOEventDto)
            const localVarPath = `/api/v1/webhooks/minio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookMinIOEventDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookV1Api - functional programming interface
 * @export
 */
export const WebhookV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Receive Keycloak webhook events
         * @param {WebhookKeycloakRequestDto} webhookKeycloakRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribeKeycloakEvent(webhookKeycloakRequestDto: WebhookKeycloakRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribeKeycloakEvent(webhookKeycloakRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookV1Api.subscribeKeycloakEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receive MinIO webhook events
         * @param {WebhookMinIOEventDto} webhookMinIOEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribeMinioEvent(webhookMinIOEventDto: WebhookMinIOEventDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribeMinioEvent(webhookMinIOEventDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookV1Api.subscribeMinioEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhookV1Api - factory interface
 * @export
 */
export const WebhookV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookV1ApiFp(configuration)
    return {
        /**
         * Receive Keycloak webhook events
         * @param {WebhookV1ApiSubscribeKeycloakEventRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeKeycloakEvent(requestParameters: WebhookV1ApiSubscribeKeycloakEventRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.subscribeKeycloakEvent(requestParameters.webhookKeycloakRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Receive MinIO webhook events
         * @param {WebhookV1ApiSubscribeMinioEventRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeMinioEvent(requestParameters: WebhookV1ApiSubscribeMinioEventRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.subscribeMinioEvent(requestParameters.webhookMinIOEventDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for subscribeKeycloakEvent operation in WebhookV1Api.
 * @export
 * @interface WebhookV1ApiSubscribeKeycloakEventRequest
 */
export interface WebhookV1ApiSubscribeKeycloakEventRequest {
    /**
     * 
     * @type {WebhookKeycloakRequestDto}
     * @memberof WebhookV1ApiSubscribeKeycloakEvent
     */
    readonly webhookKeycloakRequestDto: WebhookKeycloakRequestDto
}

/**
 * Request parameters for subscribeMinioEvent operation in WebhookV1Api.
 * @export
 * @interface WebhookV1ApiSubscribeMinioEventRequest
 */
export interface WebhookV1ApiSubscribeMinioEventRequest {
    /**
     * 
     * @type {WebhookMinIOEventDto}
     * @memberof WebhookV1ApiSubscribeMinioEvent
     */
    readonly webhookMinIOEventDto: WebhookMinIOEventDto
}

/**
 * WebhookV1Api - object-oriented interface
 * @export
 * @class WebhookV1Api
 * @extends {BaseAPI}
 */
export class WebhookV1Api extends BaseAPI {
    /**
     * Receive Keycloak webhook events
     * @param {WebhookV1ApiSubscribeKeycloakEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookV1Api
     */
    public subscribeKeycloakEvent(requestParameters: WebhookV1ApiSubscribeKeycloakEventRequest, options?: RawAxiosRequestConfig) {
        return WebhookV1ApiFp(this.configuration).subscribeKeycloakEvent(requestParameters.webhookKeycloakRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receive MinIO webhook events
     * @param {WebhookV1ApiSubscribeMinioEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookV1Api
     */
    public subscribeMinioEvent(requestParameters: WebhookV1ApiSubscribeMinioEventRequest, options?: RawAxiosRequestConfig) {
        return WebhookV1ApiFp(this.configuration).subscribeMinioEvent(requestParameters.webhookMinIOEventDto, options).then((request) => request(this.axios, this.basePath));
    }
}



