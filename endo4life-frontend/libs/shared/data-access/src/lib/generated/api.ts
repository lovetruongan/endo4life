/* tslint:disable */
/* eslint-disable */
/**
 * E-learning APIs
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AnswerMetadata
 */
export interface AnswerMetadata {
    /**
     * 
     * @type {string}
     * @memberof AnswerMetadata
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnswerMetadata
     */
    'content'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AnswerMetadata
     */
    'isCorrect'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AnswerMetadata
     */
    'essay_answer'?: string;
}
/**
 * 
 * @export
 * @interface AnswerWrapperDto
 */
export interface AnswerWrapperDto {
    /**
     * 
     * @type {Array<AnswerMetadata>}
     * @memberof AnswerWrapperDto
     */
    'metadata'?: Array<AnswerMetadata>;
}
/**
 * 
 * @export
 * @interface CommentCriteria
 */
export interface CommentCriteria {
    /**
     * 
     * @type {string}
     * @memberof CommentCriteria
     */
    'resourceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentCriteria
     */
    'courseId'?: string;
}
/**
 * 
 * @export
 * @interface CommentResponseDto
 */
export interface CommentResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CommentResponseDto
     */
    'id'?: string;
    /**
     * content
     * @type {string}
     * @memberof CommentResponseDto
     */
    'content'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CommentResponseDto
     */
    'attachments'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CommentResponseDto
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentResponseDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {CommentResponseDto}
     * @memberof CommentResponseDto
     */
    'comment'?: CommentResponseDto;
}
/**
 * 
 * @export
 * @interface CommentResponsePaginatedDto
 */
export interface CommentResponsePaginatedDto {
    /**
     * 
     * @type {Array<CommentResponseDto>}
     * @memberof CommentResponsePaginatedDto
     */
    'data'?: Array<CommentResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof CommentResponsePaginatedDto
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface CourseCriteria
 */
export interface CourseCriteria {
    /**
     * Title of course
     * @type {string}
     * @memberof CourseCriteria
     */
    'title'?: string;
    /**
     * 
     * @type {CourseState}
     * @memberof CourseCriteria
     */
    'state'?: CourseState;
}


/**
 * 
 * @export
 * @interface CourseResponseDto
 */
export interface CourseResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CourseResponseDto
     */
    'id'?: string;
    /**
     * Tags specification for course
     * @type {Array<string>}
     * @memberof CourseResponseDto
     */
    'tags'?: Array<string>;
    /**
     * Tags detail specification for course
     * @type {Array<string>}
     * @memberof CourseResponseDto
     */
    'tagsDetail'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CourseResponseDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseResponseDto
     */
    'lecturer'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseResponseDto
     */
    'title'?: string;
    /**
     * 
     * @type {CourseState}
     * @memberof CourseResponseDto
     */
    'state'?: CourseState;
    /**
     * 
     * @type {string}
     * @memberof CourseResponseDto
     */
    'thumbnailUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseResponseDto
     */
    'lastUpdated'?: string;
}


/**
 * 
 * @export
 * @interface CourseResponsePaginatedDto
 */
export interface CourseResponsePaginatedDto {
    /**
     * 
     * @type {Array<CourseResponseDto>}
     * @memberof CourseResponsePaginatedDto
     */
    'data'?: Array<CourseResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof CourseResponsePaginatedDto
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface CourseSectionCriteria
 */
export interface CourseSectionCriteria {
    /**
     * 
     * @type {string}
     * @memberof CourseSectionCriteria
     */
    'courseId'?: string;
    /**
     * Title of course
     * @type {string}
     * @memberof CourseSectionCriteria
     */
    'title'?: string;
    /**
     * 
     * @type {CourseState}
     * @memberof CourseSectionCriteria
     */
    'state'?: CourseState;
}


/**
 * 
 * @export
 * @interface CourseSectionResponseDto
 */
export interface CourseSectionResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CourseSectionResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseSectionResponseDto
     */
    'title'?: string;
    /**
     * 
     * @type {CourseState}
     * @memberof CourseSectionResponseDto
     */
    'state'?: CourseState;
    /**
     * 
     * @type {string}
     * @memberof CourseSectionResponseDto
     */
    'thumbnailUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseSectionResponseDto
     */
    'attachments'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseSectionResponseDto
     */
    'lastUpdated'?: string;
}


/**
 * 
 * @export
 * @interface CourseSectionResponsePaginatedDto
 */
export interface CourseSectionResponsePaginatedDto {
    /**
     * 
     * @type {Array<CourseSectionResponseDto>}
     * @memberof CourseSectionResponsePaginatedDto
     */
    'data'?: Array<CourseSectionResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof CourseSectionResponsePaginatedDto
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CourseState = {
    Public: 'PUBLIC',
    Draft: 'DRAFT',
    Unlisted: 'UNLISTED'
} as const;

export type CourseState = typeof CourseState[keyof typeof CourseState];


/**
 * 
 * @export
 * @interface CreateCommentRequestDto
 */
export interface CreateCommentRequestDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCommentRequestDto
     */
    'attachments'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateCommentRequestDto
     */
    'resourceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCommentRequestDto
     */
    'courseId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCommentRequestDto
     */
    'parentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCommentRequestDto
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCommentRequestDto
     */
    'userInfoId': string;
}
/**
 * 
 * @export
 * @interface CreateCourseRequestDto
 */
export interface CreateCourseRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateCourseRequestDto
     */
    'thumbnail'?: string;
    /**
     * 
     * @type {CourseState}
     * @memberof CreateCourseRequestDto
     */
    'state'?: CourseState;
    /**
     * Title of course
     * @type {string}
     * @memberof CreateCourseRequestDto
     */
    'title': string;
    /**
     * Description of course
     * @type {string}
     * @memberof CreateCourseRequestDto
     */
    'description': string;
    /**
     * Lecturer of course
     * @type {string}
     * @memberof CreateCourseRequestDto
     */
    'lecturer': string;
    /**
     * Tags specification for course
     * @type {Array<string>}
     * @memberof CreateCourseRequestDto
     */
    'tags'?: Array<string>;
    /**
     * Tags detail specification for course
     * @type {Array<string>}
     * @memberof CreateCourseRequestDto
     */
    'tagsDetail'?: Array<string>;
}


/**
 * 
 * @export
 * @interface CreateCourseSectionRequestDto
 */
export interface CreateCourseSectionRequestDto {
    /**
     * courseId of a course section.
     * @type {string}
     * @memberof CreateCourseSectionRequestDto
     */
    'courseId': string;
    /**
     * 
     * @type {CourseState}
     * @memberof CreateCourseSectionRequestDto
     */
    'state'?: CourseState;
    /**
     * Title of a course section.
     * @type {string}
     * @memberof CreateCourseSectionRequestDto
     */
    'title'?: string;
    /**
     * 
     * @type {CreateCourseSectionRequestDtoAttribute}
     * @memberof CreateCourseSectionRequestDto
     */
    'attribute'?: CreateCourseSectionRequestDtoAttribute;
    /**
     * total credits of a course section.
     * @type {number}
     * @memberof CreateCourseSectionRequestDto
     */
    'totalCredits'?: number;
    /**
     * Tags specification for a course section.
     * @type {Array<string>}
     * @memberof CreateCourseSectionRequestDto
     */
    'tags'?: Array<string>;
    /**
     * Tags detail specification for a course section.
     * @type {Array<string>}
     * @memberof CreateCourseSectionRequestDto
     */
    'tagsDetail'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseSectionRequestDto
     */
    'thumbnail'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseSectionRequestDto
     */
    'attachments'?: string;
}


/**
 * 
 * @export
 * @interface CreateCourseSectionRequestDtoAttribute
 */
export interface CreateCourseSectionRequestDtoAttribute {
    /**
     * 
     * @type {MetaDataCourseSectionDto}
     * @memberof CreateCourseSectionRequestDtoAttribute
     */
    'metadata'?: MetaDataCourseSectionDto;
}
/**
 * 
 * @export
 * @interface CreateDoctorUserConversationDto
 */
export interface CreateDoctorUserConversationDto {
    /**
     * 
     * @type {DoctorUserConversationState}
     * @memberof CreateDoctorUserConversationDto
     */
    'state': DoctorUserConversationState;
    /**
     * 
     * @type {DoctorUserConversationType}
     * @memberof CreateDoctorUserConversationDto
     */
    'type': DoctorUserConversationType;
    /**
     * 
     * @type {string}
     * @memberof CreateDoctorUserConversationDto
     */
    'resourceId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateDoctorUserConversationDto
     */
    'questionerId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateDoctorUserConversationDto
     */
    'assigneeId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDoctorUserConversationDto
     */
    'content': string;
    /**
     * A list of images attachmented for conversations between doctor and user.
     * @type {Array<File>}
     * @memberof CreateDoctorUserConversationDto
     */
    'images'?: Array<File>;
}


/**
 * 
 * @export
 * @interface CreateResourceRequest
 */
export interface CreateResourceRequest {
    /**
     * 
     * @type {UploadType}
     * @memberof CreateResourceRequest
     */
    'type': UploadType;
    /**
     * 
     * @type {Array<CreateResourceRequestDto>}
     * @memberof CreateResourceRequest
     */
    'metadata'?: Array<CreateResourceRequestDto>;
}


/**
 * 
 * @export
 * @interface CreateResourceRequestDto
 */
export interface CreateResourceRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateResourceRequestDto
     */
    'thumbnail': string;
    /**
     * 
     * @type {string}
     * @memberof CreateResourceRequestDto
     */
    'objectKey'?: string;
    /**
     * Title of the resource
     * @type {string}
     * @memberof CreateResourceRequestDto
     */
    'title': string;
    /**
     * Description of the resource
     * @type {string}
     * @memberof CreateResourceRequestDto
     */
    'description': string;
    /**
     * 
     * @type {ResourceState & string}
     * @memberof CreateResourceRequestDto
     */
    'state'?: ResourceState & string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateResourceRequestDto
     */
    'tag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateResourceRequestDto
     */
    'detailTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateResourceRequestDto
     */
    'anatomyLocationTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateResourceRequestDto
     */
    'lightTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateResourceRequestDto
     */
    'hpTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateResourceRequestDto
     */
    'upperGastroAnatomyTag'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateTagRequestDto
 */
export interface CreateTagRequestDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateTagRequestDto
     */
    'tag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateTagRequestDto
     */
    'detailTag'?: Array<string>;
    /**
     * 
     * @type {TagType}
     * @memberof CreateTagRequestDto
     */
    'type'?: TagType;
}


/**
 * 
 * @export
 * @interface CreateTestRequestDto
 */
export interface CreateTestRequestDto {
    /**
     * Title for a Test
     * @type {string}
     * @memberof CreateTestRequestDto
     */
    'title'?: string;
    /**
     * Description for a Test
     * @type {string}
     * @memberof CreateTestRequestDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTestRequestDto
     */
    'courseId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTestRequestDto
     */
    'courseSectionId'?: string;
    /**
     * 
     * @type {CourseState}
     * @memberof CreateTestRequestDto
     */
    'state'?: CourseState;
    /**
     * 
     * @type {TestType}
     * @memberof CreateTestRequestDto
     */
    'type': TestType;
    /**
     * 
     * @type {Array<QuestionDto>}
     * @memberof CreateTestRequestDto
     */
    'questions'?: Array<QuestionDto>;
}


/**
 * 
 * @export
 * @interface CreateUserRequestDto
 */
export interface CreateUserRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequestDto
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequestDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequestDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequestDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequestDto
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {UserInfoRole}
     * @memberof CreateUserRequestDto
     */
    'role': UserInfoRole;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequestDto
     */
    'password': string;
    /**
     * 
     * @type {UserInfoState}
     * @memberof CreateUserRequestDto
     */
    'state'?: UserInfoState;
}


/**
 * 
 * @export
 * @interface DetailTestOfTheCourseDto
 */
export interface DetailTestOfTheCourseDto {
    /**
     * 
     * @type {string}
     * @memberof DetailTestOfTheCourseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailTestOfTheCourseDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailTestOfTheCourseDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailTestOfTheCourseDto
     */
    'courseId': string;
    /**
     * 
     * @type {CourseState}
     * @memberof DetailTestOfTheCourseDto
     */
    'state'?: CourseState;
    /**
     * 
     * @type {TestType}
     * @memberof DetailTestOfTheCourseDto
     */
    'type'?: TestType;
    /**
     * 
     * @type {Array<QuestionDetailDto>}
     * @memberof DetailTestOfTheCourseDto
     */
    'questions'?: Array<QuestionDetailDto>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const DoctorUserConversationState = {
    Public: 'PUBLIC',
    Draft: 'DRAFT'
} as const;

export type DoctorUserConversationState = typeof DoctorUserConversationState[keyof typeof DoctorUserConversationState];


/**
 * 
 * @export
 * @enum {string}
 */

export const DoctorUserConversationType = {
    Video: 'VIDEO',
    Image: 'IMAGE'
} as const;

export type DoctorUserConversationType = typeof DoctorUserConversationType[keyof typeof DoctorUserConversationType];


/**
 * 
 * @export
 * @interface GeneratePreSignedUrlDto
 */
export interface GeneratePreSignedUrlDto {
    /**
     * 
     * @type {ResourceType}
     * @memberof GeneratePreSignedUrlDto
     */
    'resourceType': ResourceType;
    /**
     * 
     * @type {number}
     * @memberof GeneratePreSignedUrlDto
     */
    'numberOfUrls': number;
}


/**
 * 
 * @export
 * @interface HealthResponseDto
 */
export interface HealthResponseDto {
    /**
     * 
     * @type {string}
     * @memberof HealthResponseDto
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface IdWrapperDto
 */
export interface IdWrapperDto {
    /**
     * 
     * @type {string}
     * @memberof IdWrapperDto
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface InformationGetResponse
 */
export interface InformationGetResponse {
    /**
     * 
     * @type {string}
     * @memberof InformationGetResponse
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof InformationGetResponse
     */
    'releaseDate'?: string;
}
/**
 * 
 * @export
 * @interface InviteUserRequestDto
 */
export interface InviteUserRequestDto {
    /**
     * Email address of the user
     * @type {string}
     * @memberof InviteUserRequestDto
     */
    'email': string;
    /**
     * 
     * @type {UserInfoRole}
     * @memberof InviteUserRequestDto
     */
    'role': UserInfoRole;
    /**
     * 
     * @type {UserInfoState}
     * @memberof InviteUserRequestDto
     */
    'state'?: UserInfoState;
}


/**
 * 
 * @export
 * @interface KeycloakAuthDetailRepresentation
 */
export interface KeycloakAuthDetailRepresentation {
    /**
     * 
     * @type {string}
     * @memberof KeycloakAuthDetailRepresentation
     */
    'realmId'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeycloakAuthDetailRepresentation
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeycloakAuthDetailRepresentation
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeycloakAuthDetailRepresentation
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeycloakAuthDetailRepresentation
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeycloakAuthDetailRepresentation
     */
    'sessionId'?: string;
}
/**
 * 
 * @export
 * @interface MetaDataCourseSectionDto
 */
export interface MetaDataCourseSectionDto {
    /**
     * 
     * @type {string}
     * @memberof MetaDataCourseSectionDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetaDataCourseSectionDto
     */
    'mainContent'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetaDataCourseSectionDto
     */
    'lessonObjectives'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetaDataCourseSectionDto
     */
    'target'?: string;
}
/**
 * This object will be overridden by Spring\'s Pageable
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    'size'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pageable
     */
    'sort'?: Array<string>;
}
/**
 * 
 * @export
 * @interface QuestionAttachmentDto
 */
export interface QuestionAttachmentDto {
    /**
     * 
     * @type {string}
     * @memberof QuestionAttachmentDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionAttachmentDto
     */
    'bucket'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionAttachmentDto
     */
    'objectKeyUrl'?: string;
    /**
     * The unique identifier of the image in MinIO
     * @type {string}
     * @memberof QuestionAttachmentDto
     */
    'objectKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof QuestionAttachmentDto
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof QuestionAttachmentDto
     */
    'height'?: number;
    /**
     * 
     * @type {string}
     * @memberof QuestionAttachmentDto
     */
    'fileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionAttachmentDto
     */
    'fileType'?: string;
    /**
     * 
     * @type {number}
     * @memberof QuestionAttachmentDto
     */
    'fileSize'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionAttachmentDto
     */
    'isDelete'?: boolean;
}
/**
 * 
 * @export
 * @interface QuestionDetailDto
 */
export interface QuestionDetailDto {
    /**
     * 
     * @type {string}
     * @memberof QuestionDetailDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionDetailDto
     */
    'title'?: string;
    /**
     * 
     * @type {QuestionType}
     * @memberof QuestionDetailDto
     */
    'type'?: QuestionType;
    /**
     * 
     * @type {string}
     * @memberof QuestionDetailDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionDetailDto
     */
    'answers'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionDetailDto
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {Array<QuestionAttachmentDto>}
     * @memberof QuestionDetailDto
     */
    'questionAttachments'?: Array<QuestionAttachmentDto>;
}


/**
 * 
 * @export
 * @interface QuestionDto
 */
export interface QuestionDto {
    /**
     * 
     * @type {string}
     * @memberof QuestionDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionDto
     */
    'title'?: string;
    /**
     * 
     * @type {QuestionType}
     * @memberof QuestionDto
     */
    'type'?: QuestionType;
    /**
     * 
     * @type {string}
     * @memberof QuestionDto
     */
    'description'?: string;
    /**
     * 
     * @type {AnswerWrapperDto}
     * @memberof QuestionDto
     */
    'answers'?: AnswerWrapperDto;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionDto
     */
    'isDelete'?: boolean;
    /**
     * 
     * @type {Array<QuestionAttachmentDto>}
     * @memberof QuestionDto
     */
    'questionAttachments'?: Array<QuestionAttachmentDto>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const QuestionType = {
    FreeText: 'FREE_TEXT',
    SingleSelect: 'SINGLE_SELECT',
    MultipleSelect: 'MULTIPLE_SELECT'
} as const;

export type QuestionType = typeof QuestionType[keyof typeof QuestionType];


/**
 * 
 * @export
 * @interface ResourceCriteria
 */
export interface ResourceCriteria {
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceCriteria
     */
    'ids'?: Array<string>;
    /**
     * Title of the resource
     * @type {string}
     * @memberof ResourceCriteria
     */
    'title'?: string;
    /**
     * 
     * @type {ResourceState}
     * @memberof ResourceCriteria
     */
    'state'?: ResourceState;
    /**
     * 
     * @type {ResourceType}
     * @memberof ResourceCriteria
     */
    'resourceType'?: ResourceType;
    /**
     * 
     * @type {string}
     * @memberof ResourceCriteria
     */
    'fromDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceCriteria
     */
    'toDate'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceCriteria
     */
    'tag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceCriteria
     */
    'detailTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceCriteria
     */
    'anatomyLocationTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceCriteria
     */
    'lightTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceCriteria
     */
    'hpTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceCriteria
     */
    'upperGastroAnatomyTag'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ResourceCriteria
     */
    'commentCountTo'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceCriteria
     */
    'commentCountFrom'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceCriteria
     */
    'viewNumberTo'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceCriteria
     */
    'viewNumberFrom'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResourceCriteria
     */
    'searchWords'?: string;
}


/**
 * 
 * @export
 * @interface ResourceDetailResponseDto
 */
export interface ResourceDetailResponseDto {
    /**
     * 
     * @type {string}
     * @memberof ResourceDetailResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceDetailResponseDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceDetailResponseDto
     */
    'resourceUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceDetailResponseDto
     */
    'dimension'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceDetailResponseDto
     */
    'description'?: string;
    /**
     * 
     * @type {ResourceState}
     * @memberof ResourceDetailResponseDto
     */
    'state'?: ResourceState;
    /**
     * 
     * @type {string}
     * @memberof ResourceDetailResponseDto
     */
    'size'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceDetailResponseDto
     */
    'extension'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceDetailResponseDto
     */
    'tag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceDetailResponseDto
     */
    'detailTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceDetailResponseDto
     */
    'anatomyLocationTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceDetailResponseDto
     */
    'lightTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceDetailResponseDto
     */
    'hpTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceDetailResponseDto
     */
    'upperGastroAnatomyTag'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ResourceDetailResponseDto
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResourceDetailResponseDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceDetailResponseDto
     */
    'updatedAt'?: string;
}


/**
 * 
 * @export
 * @interface ResourceResponseDto
 */
export interface ResourceResponseDto {
    /**
     * Id of the resource
     * @type {string}
     * @memberof ResourceResponseDto
     */
    'id'?: string;
    /**
     * Title of the resource
     * @type {string}
     * @memberof ResourceResponseDto
     */
    'title'?: string;
    /**
     * 
     * @type {ResourceState}
     * @memberof ResourceResponseDto
     */
    'state'?: ResourceState;
    /**
     * url of thumbnail
     * @type {string}
     * @memberof ResourceResponseDto
     */
    'thumbnailUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResourceResponseDto
     */
    'commentCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceResponseDto
     */
    'viewNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResourceResponseDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceResponseDto
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceResponseDto
     */
    'tag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceResponseDto
     */
    'detailTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceResponseDto
     */
    'anatomyLocationTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceResponseDto
     */
    'lightTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceResponseDto
     */
    'hpTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceResponseDto
     */
    'upperGastroAnatomyTag'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ResourceResponseDto
     */
    'time'?: number;
}


/**
 * 
 * @export
 * @interface ResourceResponsePaginatedDto
 */
export interface ResourceResponsePaginatedDto {
    /**
     * 
     * @type {Array<ResourceResponseDto>}
     * @memberof ResourceResponsePaginatedDto
     */
    'data'?: Array<ResourceResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof ResourceResponsePaginatedDto
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ResourceState = {
    Public: 'PUBLIC',
    Unlisted: 'UNLISTED'
} as const;

export type ResourceState = typeof ResourceState[keyof typeof ResourceState];


/**
 * 
 * @export
 * @enum {string}
 */

export const ResourceType = {
    Video: 'VIDEO',
    Image: 'IMAGE',
    Avatar: 'AVATAR',
    Thumbnail: 'THUMBNAIL',
    Other: 'OTHER',
    Process: 'PROCESS'
} as const;

export type ResourceType = typeof ResourceType[keyof typeof ResourceType];


/**
 * 
 * @export
 * @interface ResponseDetailCourseDto
 */
export interface ResponseDetailCourseDto {
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseDto
     */
    'id'?: string;
    /**
     * 
     * @type {CourseState}
     * @memberof ResponseDetailCourseDto
     */
    'state'?: CourseState;
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseDto
     */
    'lecturer'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseDetailCourseDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseDetailCourseDto
     */
    'tagsDetail'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseDto
     */
    'thumbnailUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseDto
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseDto
     */
    'updatedBy'?: string;
}


/**
 * 
 * @export
 * @interface ResponseDetailCourseSectionDto
 */
export interface ResponseDetailCourseSectionDto {
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseSectionDto
     */
    'id'?: string;
    /**
     * 
     * @type {CourseState}
     * @memberof ResponseDetailCourseSectionDto
     */
    'state'?: CourseState;
    /**
     * 
     * @type {DetailTestOfTheCourseDto}
     * @memberof ResponseDetailCourseSectionDto
     */
    'lectureReviewQuestionsDto'?: DetailTestOfTheCourseDto;
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseSectionDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseSectionDto
     */
    'attribute'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseDetailCourseSectionDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseDetailCourseSectionDto
     */
    'tagsDetail'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseSectionDto
     */
    'thumbnailUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseSectionDto
     */
    'attachmentUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseSectionDto
     */
    'attachment'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseSectionDto
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseDetailCourseSectionDto
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResponseDetailCourseSectionDto
     */
    'totalCredits'?: number;
}


/**
 * 
 * @export
 * @interface TagResponseDto
 */
export interface TagResponseDto {
    /**
     * 
     * @type {string}
     * @memberof TagResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TagResponseDto
     */
    'content'?: string;
    /**
     * 
     * @type {TagType}
     * @memberof TagResponseDto
     */
    'type'?: TagType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TagType = {
    DamageTag: 'DAMAGE_TAG',
    AnatomyLocationTag: 'ANATOMY_LOCATION_TAG',
    HpTag: 'HP_TAG',
    LightTag: 'LIGHT_TAG',
    UpperGastroAnatomyTag: 'UPPER_GASTRO_ANATOMY_TAG'
} as const;

export type TagType = typeof TagType[keyof typeof TagType];


/**
 * 
 * @export
 * @enum {string}
 */

export const TestType = {
    EntranceTestCourse: 'ENTRANCE_TEST_COURSE',
    FinalExamCourse: 'FINAL_EXAM_COURSE',
    SurveyCourse: 'SURVEY_COURSE',
    LectureReviewQuestionsCourse: 'LECTURE_REVIEW_QUESTIONS_COURSE'
} as const;

export type TestType = typeof TestType[keyof typeof TestType];


/**
 * 
 * @export
 * @interface UpdateCourseRequestDto
 */
export interface UpdateCourseRequestDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseRequestDto
     */
    'thumbnail'?: string;
    /**
     * 
     * @type {CourseState}
     * @memberof UpdateCourseRequestDto
     */
    'state'?: CourseState;
    /**
     * Title of course
     * @type {string}
     * @memberof UpdateCourseRequestDto
     */
    'title'?: string;
    /**
     * Description of course
     * @type {string}
     * @memberof UpdateCourseRequestDto
     */
    'description'?: string;
    /**
     * Lecturer of course
     * @type {string}
     * @memberof UpdateCourseRequestDto
     */
    'lecturer'?: string;
    /**
     * Tags specification for course
     * @type {Array<string>}
     * @memberof UpdateCourseRequestDto
     */
    'tags'?: Array<string>;
    /**
     * Tags detail specification for course
     * @type {Array<string>}
     * @memberof UpdateCourseRequestDto
     */
    'tagsDetail'?: Array<string>;
}


/**
 * 
 * @export
 * @interface UpdateCourseSectionRequestDto
 */
export interface UpdateCourseSectionRequestDto {
    /**
     * 
     * @type {CourseState}
     * @memberof UpdateCourseSectionRequestDto
     */
    'state'?: CourseState;
    /**
     * Title of course
     * @type {string}
     * @memberof UpdateCourseSectionRequestDto
     */
    'title'?: string;
    /**
     * Tags specification for course
     * @type {Array<string>}
     * @memberof UpdateCourseSectionRequestDto
     */
    'tags'?: Array<string>;
    /**
     * Tags detail specification for course
     * @type {Array<string>}
     * @memberof UpdateCourseSectionRequestDto
     */
    'tagsDetail'?: Array<string>;
    /**
     * total credits of a course section.
     * @type {number}
     * @memberof UpdateCourseSectionRequestDto
     */
    'totalCredits'?: number;
    /**
     * 
     * @type {CreateCourseSectionRequestDtoAttribute}
     * @memberof UpdateCourseSectionRequestDto
     */
    'attribute'?: CreateCourseSectionRequestDtoAttribute;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseSectionRequestDto
     */
    'thumbnail'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCourseSectionRequestDto
     */
    'attachments'?: string;
}


/**
 * 
 * @export
 * @interface UpdateResourceRequestDto
 */
export interface UpdateResourceRequestDto {
    /**
     * Title of the resource
     * @type {string}
     * @memberof UpdateResourceRequestDto
     */
    'title'?: string;
    /**
     * Description of the resource
     * @type {string}
     * @memberof UpdateResourceRequestDto
     */
    'description'?: string;
    /**
     * 
     * @type {ResourceState}
     * @memberof UpdateResourceRequestDto
     */
    'state'?: ResourceState;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateResourceRequestDto
     */
    'tag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateResourceRequestDto
     */
    'detailTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateResourceRequestDto
     */
    'anatomyLocationTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateResourceRequestDto
     */
    'lightTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateResourceRequestDto
     */
    'hpTag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateResourceRequestDto
     */
    'upperGastroAnatomyTag'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateResourceRequestDto
     */
    'thumbnail'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateResourceRequestDto
     */
    'attachment'?: string;
    /**
     * 
     * @type {UploadType}
     * @memberof UpdateResourceRequestDto
     */
    'typeAttachment'?: UploadType;
}


/**
 * 
 * @export
 * @interface UpdateTestRequestDto
 */
export interface UpdateTestRequestDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateTestRequestDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTestRequestDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTestRequestDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTestRequestDto
     */
    'courseId': string;
    /**
     * 
     * @type {CourseState}
     * @memberof UpdateTestRequestDto
     */
    'state'?: CourseState;
    /**
     * 
     * @type {TestType}
     * @memberof UpdateTestRequestDto
     */
    'type'?: TestType;
    /**
     * 
     * @type {Array<QuestionDto>}
     * @memberof UpdateTestRequestDto
     */
    'questions'?: Array<QuestionDto>;
}


/**
 * 
 * @export
 * @interface UpdateUserRequestDto
 */
export interface UpdateUserRequestDto {
    /**
     * Phone number of the user
     * @type {string}
     * @memberof UpdateUserRequestDto
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {UserInfoRole}
     * @memberof UpdateUserRequestDto
     */
    'role'?: UserInfoRole;
    /**
     * 
     * @type {UserInfoState}
     * @memberof UpdateUserRequestDto
     */
    'state'?: UserInfoState;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserRequestDto
     */
    'isUpdatedProfile'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequestDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequestDto
     */
    'lastName'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const UploadType = {
    Video: 'VIDEO',
    Image: 'IMAGE',
    Compressed: 'COMPRESSED',
    Other: 'OTHER'
} as const;

export type UploadType = typeof UploadType[keyof typeof UploadType];


/**
 * 
 * @export
 * @interface UserInfoCriteria
 */
export interface UserInfoCriteria {
    /**
     * 
     * @type {Array<string>}
     * @memberof UserInfoCriteria
     */
    'ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserInfoCriteria
     */
    'emails'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserInfoCriteria
     */
    'searchWord'?: string;
    /**
     * 
     * @type {UserInfoRole}
     * @memberof UserInfoCriteria
     */
    'role'?: UserInfoRole;
    /**
     * 
     * @type {UserInfoState}
     * @memberof UserInfoCriteria
     */
    'state'?: UserInfoState;
    /**
     * 
     * @type {string}
     * @memberof UserInfoCriteria
     */
    'fromDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoCriteria
     */
    'toDate'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const UserInfoRole = {
    Admin: 'ADMIN',
    Specialist: 'SPECIALIST',
    Coordinator: 'COORDINATOR',
    Customer: 'CUSTOMER'
} as const;

export type UserInfoRole = typeof UserInfoRole[keyof typeof UserInfoRole];


/**
 * 
 * @export
 * @enum {string}
 */

export const UserInfoState = {
    Active: 'ACTIVE',
    Pending: 'PENDING',
    Inactive: 'INACTIVE'
} as const;

export type UserInfoState = typeof UserInfoState[keyof typeof UserInfoState];


/**
 * 
 * @export
 * @interface UserResourceDetailResponseDto
 */
export interface UserResourceDetailResponseDto {
    /**
     * 
     * @type {string}
     * @memberof UserResourceDetailResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResourceDetailResponseDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResourceDetailResponseDto
     */
    'resourceUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResourceDetailResponseDto
     */
    'dimension'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResourceDetailResponseDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResourceDetailResponseDto
     */
    'extension'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserResourceDetailResponseDto
     */
    'tag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserResourceDetailResponseDto
     */
    'detailTag'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof UserResourceDetailResponseDto
     */
    'time'?: number;
    /**
     * Type of resource (VIDEO/IMAGE)
     * @type {string}
     * @memberof UserResourceDetailResponseDto
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResourceDetailResponseDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResourceDetailResponseDto
     */
    'createdBy'?: string;
}
/**
 * 
 * @export
 * @interface UserResourceHistoryCriteria
 */
export interface UserResourceHistoryCriteria {
    /**
     * 
     * @type {string}
     * @memberof UserResourceHistoryCriteria
     */
    'userInfoId': string;
    /**
     * 
     * @type {UserResourceType}
     * @memberof UserResourceHistoryCriteria
     */
    'type': UserResourceType;
}


/**
 * 
 * @export
 * @interface UserResourceResponseDto
 */
export interface UserResourceResponseDto {
    /**
     * Id of the resource
     * @type {string}
     * @memberof UserResourceResponseDto
     */
    'id'?: string;
    /**
     * Title of the resource
     * @type {string}
     * @memberof UserResourceResponseDto
     */
    'title'?: string;
    /**
     * url of thumbnail
     * @type {string}
     * @memberof UserResourceResponseDto
     */
    'thumbnailUrl'?: string;
    /**
     * Type of resource (VIDEO/IMAGE)
     * @type {string}
     * @memberof UserResourceResponseDto
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResourceResponseDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResourceResponseDto
     */
    'createdBy'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserResourceResponseDto
     */
    'tag'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserResourceResponseDto
     */
    'detailTag'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof UserResourceResponseDto
     */
    'time'?: number;
}
/**
 * 
 * @export
 * @interface UserResourceResponsePaginatedDto
 */
export interface UserResourceResponsePaginatedDto {
    /**
     * 
     * @type {Array<UserResourceResponseDto>}
     * @memberof UserResourceResponsePaginatedDto
     */
    'data'?: Array<UserResourceResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof UserResourceResponsePaginatedDto
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UserResourceType = {
    Image: 'IMAGE',
    Video: 'VIDEO'
} as const;

export type UserResourceType = typeof UserResourceType[keyof typeof UserResourceType];


/**
 * 
 * @export
 * @interface UserResourcesAccessedResponseDto
 */
export interface UserResourcesAccessedResponseDto {
    /**
     * 
     * @type {string}
     * @memberof UserResourcesAccessedResponseDto
     */
    'thumbnailUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResourcesAccessedResponseDto
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResourcesAccessedResponseDto
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserResourcesAccessedResponseDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserResourcesAccessedResponseDto
     */
    'tagsDetail'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof UserResourcesAccessedResponseDto
     */
    'videoDuration'?: number;
}
/**
 * 
 * @export
 * @interface UserResourcesAccessedResponsePaginatedDto
 */
export interface UserResourcesAccessedResponsePaginatedDto {
    /**
     * 
     * @type {Array<UserResourcesAccessedResponseDto>}
     * @memberof UserResourcesAccessedResponsePaginatedDto
     */
    'data'?: Array<UserResourcesAccessedResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof UserResourcesAccessedResponsePaginatedDto
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface UserResponseDto
 */
export interface UserResponseDto {
    /**
     * Id of the user
     * @type {string}
     * @memberof UserResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'userId'?: string;
    /**
     * Username of the user
     * @type {string}
     * @memberof UserResponseDto
     */
    'username'?: string;
    /**
     * First name of user
     * @type {string}
     * @memberof UserResponseDto
     */
    'firstName'?: string;
    /**
     * Last name of user
     * @type {string}
     * @memberof UserResponseDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {UserInfoRole}
     * @memberof UserResponseDto
     */
    'role'?: UserInfoRole;
    /**
     * Email address of the user
     * @type {string}
     * @memberof UserResponseDto
     */
    'email'?: string;
    /**
     * Phone number of the user
     * @type {string}
     * @memberof UserResponseDto
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {UserInfoState}
     * @memberof UserResponseDto
     */
    'state'?: UserInfoState;
    /**
     * Check if profile is updated or not
     * @type {boolean}
     * @memberof UserResponseDto
     */
    'isUpdatedProfile'?: boolean;
    /**
     * Link to avatar
     * @type {string}
     * @memberof UserResponseDto
     */
    'avatarLink'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserResponseDto
     */
    'certificateLinks'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'updatedAt'?: string;
}


/**
 * 
 * @export
 * @interface UserResponsePaginatedDto
 */
export interface UserResponsePaginatedDto {
    /**
     * 
     * @type {Array<UserResponseDto>}
     * @memberof UserResponsePaginatedDto
     */
    'data'?: Array<UserResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof UserResponsePaginatedDto
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface WebhookKeycloakRequestDto
 */
export interface WebhookKeycloakRequestDto {
    /**
     * 
     * @type {string}
     * @memberof WebhookKeycloakRequestDto
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookKeycloakRequestDto
     */
    'realmId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookKeycloakRequestDto
     */
    'organizationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookKeycloakRequestDto
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookKeycloakRequestDto
     */
    'representation'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookKeycloakRequestDto
     */
    'operationType'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookKeycloakRequestDto
     */
    'resourcePath'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookKeycloakRequestDto
     */
    'resourceType'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookKeycloakRequestDto
     */
    'error'?: string;
    /**
     * 
     * @type {KeycloakAuthDetailRepresentation}
     * @memberof WebhookKeycloakRequestDto
     */
    'authDetails'?: KeycloakAuthDetailRepresentation;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof WebhookKeycloakRequestDto
     */
    'details'?: { [key: string]: any | undefined; };
}
/**
 * 
 * @export
 * @interface WebhookMinIOEventDto
 */
export interface WebhookMinIOEventDto {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof WebhookMinIOEventDto
     */
    'EventName'?: string;
    /**
     * <bucket>/<object_key>
     * @type {string}
     * @memberof WebhookMinIOEventDto
     */
    'Key'?: string;
    /**
     * 
     * @type {Array<WebhookMinIOEventDtoRecordsInner>}
     * @memberof WebhookMinIOEventDto
     */
    'Records'?: Array<WebhookMinIOEventDtoRecordsInner>;
}
/**
 * 
 * @export
 * @interface WebhookMinIOEventDtoRecordsInner
 */
export interface WebhookMinIOEventDtoRecordsInner {
    /**
     * 
     * @type {string}
     * @memberof WebhookMinIOEventDtoRecordsInner
     */
    'eventVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookMinIOEventDtoRecordsInner
     */
    'eventSource'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookMinIOEventDtoRecordsInner
     */
    'awsRegion'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookMinIOEventDtoRecordsInner
     */
    'eventTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookMinIOEventDtoRecordsInner
     */
    'eventName'?: string;
    /**
     * 
     * @type {object}
     * @memberof WebhookMinIOEventDtoRecordsInner
     */
    'userIdentity'?: object;
    /**
     * 
     * @type {object}
     * @memberof WebhookMinIOEventDtoRecordsInner
     */
    'requestParameters'?: object;
    /**
     * 
     * @type {object}
     * @memberof WebhookMinIOEventDtoRecordsInner
     */
    'responseElements'?: object;
    /**
     * 
     * @type {object}
     * @memberof WebhookMinIOEventDtoRecordsInner
     */
    's3'?: object;
    /**
     * 
     * @type {object}
     * @memberof WebhookMinIOEventDtoRecordsInner
     */
    'source'?: object;
}

/**
 * ActuatorApi - axios parameter creator
 * @export
 */
export const ActuatorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get health status of backend service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actuatorHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/actuator/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about ai-assistance service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actuatorInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/actuator/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActuatorApi - functional programming interface
 * @export
 */
export const ActuatorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActuatorApiAxiosParamCreator(configuration)
    return {
        /**
         * Get health status of backend service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actuatorHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actuatorHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActuatorApi.actuatorHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about ai-assistance service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actuatorInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InformationGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actuatorInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActuatorApi.actuatorInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActuatorApi - factory interface
 * @export
 */
export const ActuatorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActuatorApiFp(configuration)
    return {
        /**
         * Get health status of backend service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actuatorHealth(options?: RawAxiosRequestConfig): AxiosPromise<HealthResponseDto> {
            return localVarFp.actuatorHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about ai-assistance service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actuatorInfo(options?: RawAxiosRequestConfig): AxiosPromise<InformationGetResponse> {
            return localVarFp.actuatorInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActuatorApi - object-oriented interface
 * @export
 * @class ActuatorApi
 * @extends {BaseAPI}
 */
export class ActuatorApi extends BaseAPI {
    /**
     * Get health status of backend service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApi
     */
    public actuatorHealth(options?: RawAxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).actuatorHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about ai-assistance service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApi
     */
    public actuatorInfo(options?: RawAxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).actuatorInfo(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CommentV1Api - axios parameter creator
 * @export
 */
export const CommentV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCommentRequestDto} createCommentRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment: async (createCommentRequestDto: CreateCommentRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCommentRequestDto' is not null or undefined
            assertParamExists('createComment', 'createCommentRequestDto', createCommentRequestDto)
            const localVarPath = `/api/v1/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCommentRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all comments with criteria
         * @param {CommentCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments: async (criteria?: CommentCriteria, pageable?: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (criteria !== undefined) {
                for (const [key, value] of Object.entries(criteria)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentV1Api - functional programming interface
 * @export
 */
export const CommentV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommentV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateCommentRequestDto} createCommentRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createComment(createCommentRequestDto: CreateCommentRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdWrapperDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createComment(createCommentRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentV1Api.createComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all comments with criteria
         * @param {CommentCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getComments(criteria?: CommentCriteria, pageable?: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentResponsePaginatedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getComments(criteria, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentV1Api.getComments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CommentV1Api - factory interface
 * @export
 */
export const CommentV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommentV1ApiFp(configuration)
    return {
        /**
         * 
         * @param {CommentV1ApiCreateCommentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment(requestParameters: CommentV1ApiCreateCommentRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdWrapperDto> {
            return localVarFp.createComment(requestParameters.createCommentRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all comments with criteria
         * @param {CommentV1ApiGetCommentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(requestParameters: CommentV1ApiGetCommentsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CommentResponsePaginatedDto> {
            return localVarFp.getComments(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createComment operation in CommentV1Api.
 * @export
 * @interface CommentV1ApiCreateCommentRequest
 */
export interface CommentV1ApiCreateCommentRequest {
    /**
     * 
     * @type {CreateCommentRequestDto}
     * @memberof CommentV1ApiCreateComment
     */
    readonly createCommentRequestDto: CreateCommentRequestDto
}

/**
 * Request parameters for getComments operation in CommentV1Api.
 * @export
 * @interface CommentV1ApiGetCommentsRequest
 */
export interface CommentV1ApiGetCommentsRequest {
    /**
     * 
     * @type {CommentCriteria}
     * @memberof CommentV1ApiGetComments
     */
    readonly criteria?: CommentCriteria

    /**
     * 
     * @type {Pageable}
     * @memberof CommentV1ApiGetComments
     */
    readonly pageable?: Pageable
}

/**
 * CommentV1Api - object-oriented interface
 * @export
 * @class CommentV1Api
 * @extends {BaseAPI}
 */
export class CommentV1Api extends BaseAPI {
    /**
     * 
     * @param {CommentV1ApiCreateCommentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentV1Api
     */
    public createComment(requestParameters: CommentV1ApiCreateCommentRequest, options?: RawAxiosRequestConfig) {
        return CommentV1ApiFp(this.configuration).createComment(requestParameters.createCommentRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all comments with criteria
     * @param {CommentV1ApiGetCommentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentV1Api
     */
    public getComments(requestParameters: CommentV1ApiGetCommentsRequest = {}, options?: RawAxiosRequestConfig) {
        return CommentV1ApiFp(this.configuration).getComments(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CourseSectionV1Api - axios parameter creator
 * @export
 */
export const CourseSectionV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new course-section for a Course.
         * @param {CreateCourseSectionRequestDto} courseSection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseSection: async (courseSection: CreateCourseSectionRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseSection' is not null or undefined
            assertParamExists('createCourseSection', 'courseSection', courseSection)
            const localVarPath = `/api/v1/course-sections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (courseSection !== undefined) { 
                localVarFormParams.append('courseSection', new Blob([JSON.stringify(courseSection)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Course Section.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseSection: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCourseSection', 'id', id)
            const localVarPath = `/api/v1/course-sections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete list ids of course sections.
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseSections: async (ids: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteCourseSections', 'ids', ids)
            const localVarPath = `/api/v1/course-sections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get course section by ID.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseSectionById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCourseSectionById', 'id', id)
            const localVarPath = `/api/v1/course-sections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Course sections
         * @param {CourseSectionCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseSections: async (criteria?: CourseSectionCriteria, pageable?: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/course-sections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (criteria !== undefined) {
                for (const [key, value] of Object.entries(criteria)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing course section.
         * @param {string} id 
         * @param {UpdateCourseSectionRequestDto} metadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseSection: async (id: string, metadata: UpdateCourseSectionRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCourseSection', 'id', id)
            // verify required parameter 'metadata' is not null or undefined
            assertParamExists('updateCourseSection', 'metadata', metadata)
            const localVarPath = `/api/v1/course-sections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (metadata !== undefined) { 
                localVarFormParams.append('metadata', new Blob([JSON.stringify(metadata)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseSectionV1Api - functional programming interface
 * @export
 */
export const CourseSectionV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseSectionV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new course-section for a Course.
         * @param {CreateCourseSectionRequestDto} courseSection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCourseSection(courseSection: CreateCourseSectionRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdWrapperDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCourseSection(courseSection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseSectionV1Api.createCourseSection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a Course Section.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCourseSection(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCourseSection(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseSectionV1Api.deleteCourseSection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete list ids of course sections.
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCourseSections(ids: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCourseSections(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseSectionV1Api.deleteCourseSections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get course section by ID.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseSectionById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDetailCourseSectionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseSectionById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseSectionV1Api.getCourseSectionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all Course sections
         * @param {CourseSectionCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseSections(criteria?: CourseSectionCriteria, pageable?: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseSectionResponsePaginatedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseSections(criteria, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseSectionV1Api.getCourseSections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing course section.
         * @param {string} id 
         * @param {UpdateCourseSectionRequestDto} metadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCourseSection(id: string, metadata: UpdateCourseSectionRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdWrapperDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCourseSection(id, metadata, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseSectionV1Api.updateCourseSection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CourseSectionV1Api - factory interface
 * @export
 */
export const CourseSectionV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseSectionV1ApiFp(configuration)
    return {
        /**
         * Create a new course-section for a Course.
         * @param {CourseSectionV1ApiCreateCourseSectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseSection(requestParameters: CourseSectionV1ApiCreateCourseSectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdWrapperDto> {
            return localVarFp.createCourseSection(requestParameters.courseSection, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Course Section.
         * @param {CourseSectionV1ApiDeleteCourseSectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseSection(requestParameters: CourseSectionV1ApiDeleteCourseSectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCourseSection(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete list ids of course sections.
         * @param {CourseSectionV1ApiDeleteCourseSectionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseSections(requestParameters: CourseSectionV1ApiDeleteCourseSectionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCourseSections(requestParameters.ids, options).then((request) => request(axios, basePath));
        },
        /**
         * Get course section by ID.
         * @param {CourseSectionV1ApiGetCourseSectionByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseSectionById(requestParameters: CourseSectionV1ApiGetCourseSectionByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResponseDetailCourseSectionDto> {
            return localVarFp.getCourseSectionById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all Course sections
         * @param {CourseSectionV1ApiGetCourseSectionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseSections(requestParameters: CourseSectionV1ApiGetCourseSectionsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CourseSectionResponsePaginatedDto> {
            return localVarFp.getCourseSections(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing course section.
         * @param {CourseSectionV1ApiUpdateCourseSectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseSection(requestParameters: CourseSectionV1ApiUpdateCourseSectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdWrapperDto> {
            return localVarFp.updateCourseSection(requestParameters.id, requestParameters.metadata, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCourseSection operation in CourseSectionV1Api.
 * @export
 * @interface CourseSectionV1ApiCreateCourseSectionRequest
 */
export interface CourseSectionV1ApiCreateCourseSectionRequest {
    /**
     * 
     * @type {CreateCourseSectionRequestDto}
     * @memberof CourseSectionV1ApiCreateCourseSection
     */
    readonly courseSection: CreateCourseSectionRequestDto
}

/**
 * Request parameters for deleteCourseSection operation in CourseSectionV1Api.
 * @export
 * @interface CourseSectionV1ApiDeleteCourseSectionRequest
 */
export interface CourseSectionV1ApiDeleteCourseSectionRequest {
    /**
     * 
     * @type {string}
     * @memberof CourseSectionV1ApiDeleteCourseSection
     */
    readonly id: string
}

/**
 * Request parameters for deleteCourseSections operation in CourseSectionV1Api.
 * @export
 * @interface CourseSectionV1ApiDeleteCourseSectionsRequest
 */
export interface CourseSectionV1ApiDeleteCourseSectionsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CourseSectionV1ApiDeleteCourseSections
     */
    readonly ids: Array<string>
}

/**
 * Request parameters for getCourseSectionById operation in CourseSectionV1Api.
 * @export
 * @interface CourseSectionV1ApiGetCourseSectionByIdRequest
 */
export interface CourseSectionV1ApiGetCourseSectionByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof CourseSectionV1ApiGetCourseSectionById
     */
    readonly id: string
}

/**
 * Request parameters for getCourseSections operation in CourseSectionV1Api.
 * @export
 * @interface CourseSectionV1ApiGetCourseSectionsRequest
 */
export interface CourseSectionV1ApiGetCourseSectionsRequest {
    /**
     * 
     * @type {CourseSectionCriteria}
     * @memberof CourseSectionV1ApiGetCourseSections
     */
    readonly criteria?: CourseSectionCriteria

    /**
     * 
     * @type {Pageable}
     * @memberof CourseSectionV1ApiGetCourseSections
     */
    readonly pageable?: Pageable
}

/**
 * Request parameters for updateCourseSection operation in CourseSectionV1Api.
 * @export
 * @interface CourseSectionV1ApiUpdateCourseSectionRequest
 */
export interface CourseSectionV1ApiUpdateCourseSectionRequest {
    /**
     * 
     * @type {string}
     * @memberof CourseSectionV1ApiUpdateCourseSection
     */
    readonly id: string

    /**
     * 
     * @type {UpdateCourseSectionRequestDto}
     * @memberof CourseSectionV1ApiUpdateCourseSection
     */
    readonly metadata: UpdateCourseSectionRequestDto
}

/**
 * CourseSectionV1Api - object-oriented interface
 * @export
 * @class CourseSectionV1Api
 * @extends {BaseAPI}
 */
export class CourseSectionV1Api extends BaseAPI {
    /**
     * Create a new course-section for a Course.
     * @param {CourseSectionV1ApiCreateCourseSectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseSectionV1Api
     */
    public createCourseSection(requestParameters: CourseSectionV1ApiCreateCourseSectionRequest, options?: RawAxiosRequestConfig) {
        return CourseSectionV1ApiFp(this.configuration).createCourseSection(requestParameters.courseSection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Course Section.
     * @param {CourseSectionV1ApiDeleteCourseSectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseSectionV1Api
     */
    public deleteCourseSection(requestParameters: CourseSectionV1ApiDeleteCourseSectionRequest, options?: RawAxiosRequestConfig) {
        return CourseSectionV1ApiFp(this.configuration).deleteCourseSection(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete list ids of course sections.
     * @param {CourseSectionV1ApiDeleteCourseSectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseSectionV1Api
     */
    public deleteCourseSections(requestParameters: CourseSectionV1ApiDeleteCourseSectionsRequest, options?: RawAxiosRequestConfig) {
        return CourseSectionV1ApiFp(this.configuration).deleteCourseSections(requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get course section by ID.
     * @param {CourseSectionV1ApiGetCourseSectionByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseSectionV1Api
     */
    public getCourseSectionById(requestParameters: CourseSectionV1ApiGetCourseSectionByIdRequest, options?: RawAxiosRequestConfig) {
        return CourseSectionV1ApiFp(this.configuration).getCourseSectionById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all Course sections
     * @param {CourseSectionV1ApiGetCourseSectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseSectionV1Api
     */
    public getCourseSections(requestParameters: CourseSectionV1ApiGetCourseSectionsRequest = {}, options?: RawAxiosRequestConfig) {
        return CourseSectionV1ApiFp(this.configuration).getCourseSections(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing course section.
     * @param {CourseSectionV1ApiUpdateCourseSectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseSectionV1Api
     */
    public updateCourseSection(requestParameters: CourseSectionV1ApiUpdateCourseSectionRequest, options?: RawAxiosRequestConfig) {
        return CourseSectionV1ApiFp(this.configuration).updateCourseSection(requestParameters.id, requestParameters.metadata, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CourseV1Api - axios parameter creator
 * @export
 */
export const CourseV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Course
         * @param {CreateCourseRequestDto} course 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourse: async (course: CreateCourseRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'course' is not null or undefined
            assertParamExists('createCourse', 'course', course)
            const localVarPath = `/api/v1/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (course !== undefined) { 
                localVarFormParams.append('course', new Blob([JSON.stringify(course)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Course.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourse: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCourse', 'id', id)
            const localVarPath = `/api/v1/courses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete list ids of courses.
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourses: async (ids: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteCourses', 'ids', ids)
            const localVarPath = `/api/v1/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get course by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCourseById', 'id', id)
            const localVarPath = `/api/v1/courses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all courses.
         * @param {CourseCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses: async (criteria?: CourseCriteria, pageable?: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (criteria !== undefined) {
                for (const [key, value] of Object.entries(criteria)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing course.
         * @param {string} id 
         * @param {UpdateCourseRequestDto} metadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourse: async (id: string, metadata: UpdateCourseRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCourse', 'id', id)
            // verify required parameter 'metadata' is not null or undefined
            assertParamExists('updateCourse', 'metadata', metadata)
            const localVarPath = `/api/v1/courses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (metadata !== undefined) { 
                localVarFormParams.append('metadata', new Blob([JSON.stringify(metadata)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseV1Api - functional programming interface
 * @export
 */
export const CourseV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Course
         * @param {CreateCourseRequestDto} course 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCourse(course: CreateCourseRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdWrapperDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCourse(course, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseV1Api.createCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a Course.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCourse(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCourse(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseV1Api.deleteCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete list ids of courses.
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCourses(ids: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCourses(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseV1Api.deleteCourses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get course by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDetailCourseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseV1Api.getCourseById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all courses.
         * @param {CourseCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourses(criteria?: CourseCriteria, pageable?: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseResponsePaginatedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourses(criteria, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseV1Api.getCourses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing course.
         * @param {string} id 
         * @param {UpdateCourseRequestDto} metadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCourse(id: string, metadata: UpdateCourseRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDetailCourseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCourse(id, metadata, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseV1Api.updateCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CourseV1Api - factory interface
 * @export
 */
export const CourseV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseV1ApiFp(configuration)
    return {
        /**
         * Create a new Course
         * @param {CourseV1ApiCreateCourseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourse(requestParameters: CourseV1ApiCreateCourseRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdWrapperDto> {
            return localVarFp.createCourse(requestParameters.course, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Course.
         * @param {CourseV1ApiDeleteCourseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourse(requestParameters: CourseV1ApiDeleteCourseRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCourse(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete list ids of courses.
         * @param {CourseV1ApiDeleteCoursesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourses(requestParameters: CourseV1ApiDeleteCoursesRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCourses(requestParameters.ids, options).then((request) => request(axios, basePath));
        },
        /**
         * Get course by ID
         * @param {CourseV1ApiGetCourseByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseById(requestParameters: CourseV1ApiGetCourseByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResponseDetailCourseDto> {
            return localVarFp.getCourseById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all courses.
         * @param {CourseV1ApiGetCoursesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses(requestParameters: CourseV1ApiGetCoursesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CourseResponsePaginatedDto> {
            return localVarFp.getCourses(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing course.
         * @param {CourseV1ApiUpdateCourseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourse(requestParameters: CourseV1ApiUpdateCourseRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResponseDetailCourseDto> {
            return localVarFp.updateCourse(requestParameters.id, requestParameters.metadata, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCourse operation in CourseV1Api.
 * @export
 * @interface CourseV1ApiCreateCourseRequest
 */
export interface CourseV1ApiCreateCourseRequest {
    /**
     * 
     * @type {CreateCourseRequestDto}
     * @memberof CourseV1ApiCreateCourse
     */
    readonly course: CreateCourseRequestDto
}

/**
 * Request parameters for deleteCourse operation in CourseV1Api.
 * @export
 * @interface CourseV1ApiDeleteCourseRequest
 */
export interface CourseV1ApiDeleteCourseRequest {
    /**
     * 
     * @type {string}
     * @memberof CourseV1ApiDeleteCourse
     */
    readonly id: string
}

/**
 * Request parameters for deleteCourses operation in CourseV1Api.
 * @export
 * @interface CourseV1ApiDeleteCoursesRequest
 */
export interface CourseV1ApiDeleteCoursesRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CourseV1ApiDeleteCourses
     */
    readonly ids: Array<string>
}

/**
 * Request parameters for getCourseById operation in CourseV1Api.
 * @export
 * @interface CourseV1ApiGetCourseByIdRequest
 */
export interface CourseV1ApiGetCourseByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof CourseV1ApiGetCourseById
     */
    readonly id: string
}

/**
 * Request parameters for getCourses operation in CourseV1Api.
 * @export
 * @interface CourseV1ApiGetCoursesRequest
 */
export interface CourseV1ApiGetCoursesRequest {
    /**
     * 
     * @type {CourseCriteria}
     * @memberof CourseV1ApiGetCourses
     */
    readonly criteria?: CourseCriteria

    /**
     * 
     * @type {Pageable}
     * @memberof CourseV1ApiGetCourses
     */
    readonly pageable?: Pageable
}

/**
 * Request parameters for updateCourse operation in CourseV1Api.
 * @export
 * @interface CourseV1ApiUpdateCourseRequest
 */
export interface CourseV1ApiUpdateCourseRequest {
    /**
     * 
     * @type {string}
     * @memberof CourseV1ApiUpdateCourse
     */
    readonly id: string

    /**
     * 
     * @type {UpdateCourseRequestDto}
     * @memberof CourseV1ApiUpdateCourse
     */
    readonly metadata: UpdateCourseRequestDto
}

/**
 * CourseV1Api - object-oriented interface
 * @export
 * @class CourseV1Api
 * @extends {BaseAPI}
 */
export class CourseV1Api extends BaseAPI {
    /**
     * Create a new Course
     * @param {CourseV1ApiCreateCourseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public createCourse(requestParameters: CourseV1ApiCreateCourseRequest, options?: RawAxiosRequestConfig) {
        return CourseV1ApiFp(this.configuration).createCourse(requestParameters.course, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Course.
     * @param {CourseV1ApiDeleteCourseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public deleteCourse(requestParameters: CourseV1ApiDeleteCourseRequest, options?: RawAxiosRequestConfig) {
        return CourseV1ApiFp(this.configuration).deleteCourse(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete list ids of courses.
     * @param {CourseV1ApiDeleteCoursesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public deleteCourses(requestParameters: CourseV1ApiDeleteCoursesRequest, options?: RawAxiosRequestConfig) {
        return CourseV1ApiFp(this.configuration).deleteCourses(requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get course by ID
     * @param {CourseV1ApiGetCourseByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public getCourseById(requestParameters: CourseV1ApiGetCourseByIdRequest, options?: RawAxiosRequestConfig) {
        return CourseV1ApiFp(this.configuration).getCourseById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all courses.
     * @param {CourseV1ApiGetCoursesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public getCourses(requestParameters: CourseV1ApiGetCoursesRequest = {}, options?: RawAxiosRequestConfig) {
        return CourseV1ApiFp(this.configuration).getCourses(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing course.
     * @param {CourseV1ApiUpdateCourseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public updateCourse(requestParameters: CourseV1ApiUpdateCourseRequest, options?: RawAxiosRequestConfig) {
        return CourseV1ApiFp(this.configuration).updateCourse(requestParameters.id, requestParameters.metadata, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DoctorUserConversationsV1Api - axios parameter creator
 * @export
 */
export const DoctorUserConversationsV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * create a conversation between doctor and user.
         * @param {CreateDoctorUserConversationDto} metadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationDoctorAndUser: async (metadata: CreateDoctorUserConversationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metadata' is not null or undefined
            assertParamExists('createConversationDoctorAndUser', 'metadata', metadata)
            const localVarPath = `/api/v1/doctor-user-conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (metadata !== undefined) { 
                localVarFormParams.append('metadata', new Blob([JSON.stringify(metadata)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DoctorUserConversationsV1Api - functional programming interface
 * @export
 */
export const DoctorUserConversationsV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DoctorUserConversationsV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * create a conversation between doctor and user.
         * @param {CreateDoctorUserConversationDto} metadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConversationDoctorAndUser(metadata: CreateDoctorUserConversationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdWrapperDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConversationDoctorAndUser(metadata, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DoctorUserConversationsV1Api.createConversationDoctorAndUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DoctorUserConversationsV1Api - factory interface
 * @export
 */
export const DoctorUserConversationsV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DoctorUserConversationsV1ApiFp(configuration)
    return {
        /**
         * create a conversation between doctor and user.
         * @param {DoctorUserConversationsV1ApiCreateConversationDoctorAndUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationDoctorAndUser(requestParameters: DoctorUserConversationsV1ApiCreateConversationDoctorAndUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdWrapperDto> {
            return localVarFp.createConversationDoctorAndUser(requestParameters.metadata, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createConversationDoctorAndUser operation in DoctorUserConversationsV1Api.
 * @export
 * @interface DoctorUserConversationsV1ApiCreateConversationDoctorAndUserRequest
 */
export interface DoctorUserConversationsV1ApiCreateConversationDoctorAndUserRequest {
    /**
     * 
     * @type {CreateDoctorUserConversationDto}
     * @memberof DoctorUserConversationsV1ApiCreateConversationDoctorAndUser
     */
    readonly metadata: CreateDoctorUserConversationDto
}

/**
 * DoctorUserConversationsV1Api - object-oriented interface
 * @export
 * @class DoctorUserConversationsV1Api
 * @extends {BaseAPI}
 */
export class DoctorUserConversationsV1Api extends BaseAPI {
    /**
     * create a conversation between doctor and user.
     * @param {DoctorUserConversationsV1ApiCreateConversationDoctorAndUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoctorUserConversationsV1Api
     */
    public createConversationDoctorAndUser(requestParameters: DoctorUserConversationsV1ApiCreateConversationDoctorAndUserRequest, options?: RawAxiosRequestConfig) {
        return DoctorUserConversationsV1ApiFp(this.configuration).createConversationDoctorAndUser(requestParameters.metadata, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PreSignedUrlV1Api - axios parameter creator
 * @export
 */
export const PreSignedUrlV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API is used to generate a list of pre-signed URLs for uploading to MinIO.
         * @param {GeneratePreSignedUrlDto} generatePreSignedUrlDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePreSignedUrls: async (generatePreSignedUrlDto: GeneratePreSignedUrlDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generatePreSignedUrlDto' is not null or undefined
            assertParamExists('generatePreSignedUrls', 'generatePreSignedUrlDto', generatePreSignedUrlDto)
            const localVarPath = `/api/v1/generate/pre-signed-urls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generatePreSignedUrlDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PreSignedUrlV1Api - functional programming interface
 * @export
 */
export const PreSignedUrlV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PreSignedUrlV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * This API is used to generate a list of pre-signed URLs for uploading to MinIO.
         * @param {GeneratePreSignedUrlDto} generatePreSignedUrlDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generatePreSignedUrls(generatePreSignedUrlDto: GeneratePreSignedUrlDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generatePreSignedUrls(generatePreSignedUrlDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PreSignedUrlV1Api.generatePreSignedUrls']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PreSignedUrlV1Api - factory interface
 * @export
 */
export const PreSignedUrlV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PreSignedUrlV1ApiFp(configuration)
    return {
        /**
         * This API is used to generate a list of pre-signed URLs for uploading to MinIO.
         * @param {PreSignedUrlV1ApiGeneratePreSignedUrlsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePreSignedUrls(requestParameters: PreSignedUrlV1ApiGeneratePreSignedUrlsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.generatePreSignedUrls(requestParameters.generatePreSignedUrlDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for generatePreSignedUrls operation in PreSignedUrlV1Api.
 * @export
 * @interface PreSignedUrlV1ApiGeneratePreSignedUrlsRequest
 */
export interface PreSignedUrlV1ApiGeneratePreSignedUrlsRequest {
    /**
     * 
     * @type {GeneratePreSignedUrlDto}
     * @memberof PreSignedUrlV1ApiGeneratePreSignedUrls
     */
    readonly generatePreSignedUrlDto: GeneratePreSignedUrlDto
}

/**
 * PreSignedUrlV1Api - object-oriented interface
 * @export
 * @class PreSignedUrlV1Api
 * @extends {BaseAPI}
 */
export class PreSignedUrlV1Api extends BaseAPI {
    /**
     * This API is used to generate a list of pre-signed URLs for uploading to MinIO.
     * @param {PreSignedUrlV1ApiGeneratePreSignedUrlsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreSignedUrlV1Api
     */
    public generatePreSignedUrls(requestParameters: PreSignedUrlV1ApiGeneratePreSignedUrlsRequest, options?: RawAxiosRequestConfig) {
        return PreSignedUrlV1ApiFp(this.configuration).generatePreSignedUrls(requestParameters.generatePreSignedUrlDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResourceV1Api - axios parameter creator
 * @export
 */
export const ResourceV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new resources
         * @param {CreateResourceRequest} createResourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResource: async (createResourceRequest: CreateResourceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createResourceRequest' is not null or undefined
            assertParamExists('createResource', 'createResourceRequest', createResourceRequest)
            const localVarPath = `/api/v1/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a resource by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResource: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteResource', 'id', id)
            const localVarPath = `/api/v1/resources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete resources by list of ids
         * @param {Array<string>} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResources: async (id: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteResources', 'id', id)
            const localVarPath = `/api/v1/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a resource by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getResourceById', 'id', id)
            const localVarPath = `/api/v1/resources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all resources
         * @param {ResourceCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResources: async (criteria?: ResourceCriteria, pageable?: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (criteria !== undefined) {
                for (const [key, value] of Object.entries(criteria)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing resource
         * @param {string} id 
         * @param {UpdateResourceRequestDto} [updateResourceRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResource: async (id: string, updateResourceRequestDto?: UpdateResourceRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateResource', 'id', id)
            const localVarPath = `/api/v1/resources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceV1Api - functional programming interface
 * @export
 */
export const ResourceV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new resources
         * @param {CreateResourceRequest} createResourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResource(createResourceRequest: CreateResourceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResource(createResourceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceV1Api.createResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a resource by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResource(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResource(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceV1Api.deleteResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete resources by list of ids
         * @param {Array<string>} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResources(id: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResources(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceV1Api.deleteResources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a resource by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourceById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDetailResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceV1Api.getResourceById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all resources
         * @param {ResourceCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResources(criteria?: ResourceCriteria, pageable?: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceResponsePaginatedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResources(criteria, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceV1Api.getResources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing resource
         * @param {string} id 
         * @param {UpdateResourceRequestDto} [updateResourceRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResource(id: string, updateResourceRequestDto?: UpdateResourceRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResource(id, updateResourceRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceV1Api.updateResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourceV1Api - factory interface
 * @export
 */
export const ResourceV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceV1ApiFp(configuration)
    return {
        /**
         * Create new resources
         * @param {ResourceV1ApiCreateResourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResource(requestParameters: ResourceV1ApiCreateResourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.createResource(requestParameters.createResourceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a resource by ID
         * @param {ResourceV1ApiDeleteResourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResource(requestParameters: ResourceV1ApiDeleteResourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteResource(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete resources by list of ids
         * @param {ResourceV1ApiDeleteResourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResources(requestParameters: ResourceV1ApiDeleteResourcesRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteResources(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a resource by ID
         * @param {ResourceV1ApiGetResourceByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceById(requestParameters: ResourceV1ApiGetResourceByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResourceDetailResponseDto> {
            return localVarFp.getResourceById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all resources
         * @param {ResourceV1ApiGetResourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResources(requestParameters: ResourceV1ApiGetResourcesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ResourceResponsePaginatedDto> {
            return localVarFp.getResources(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing resource
         * @param {ResourceV1ApiUpdateResourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResource(requestParameters: ResourceV1ApiUpdateResourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateResource(requestParameters.id, requestParameters.updateResourceRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createResource operation in ResourceV1Api.
 * @export
 * @interface ResourceV1ApiCreateResourceRequest
 */
export interface ResourceV1ApiCreateResourceRequest {
    /**
     * 
     * @type {CreateResourceRequest}
     * @memberof ResourceV1ApiCreateResource
     */
    readonly createResourceRequest: CreateResourceRequest
}

/**
 * Request parameters for deleteResource operation in ResourceV1Api.
 * @export
 * @interface ResourceV1ApiDeleteResourceRequest
 */
export interface ResourceV1ApiDeleteResourceRequest {
    /**
     * 
     * @type {string}
     * @memberof ResourceV1ApiDeleteResource
     */
    readonly id: string
}

/**
 * Request parameters for deleteResources operation in ResourceV1Api.
 * @export
 * @interface ResourceV1ApiDeleteResourcesRequest
 */
export interface ResourceV1ApiDeleteResourcesRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceV1ApiDeleteResources
     */
    readonly id: Array<string>
}

/**
 * Request parameters for getResourceById operation in ResourceV1Api.
 * @export
 * @interface ResourceV1ApiGetResourceByIdRequest
 */
export interface ResourceV1ApiGetResourceByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof ResourceV1ApiGetResourceById
     */
    readonly id: string
}

/**
 * Request parameters for getResources operation in ResourceV1Api.
 * @export
 * @interface ResourceV1ApiGetResourcesRequest
 */
export interface ResourceV1ApiGetResourcesRequest {
    /**
     * 
     * @type {ResourceCriteria}
     * @memberof ResourceV1ApiGetResources
     */
    readonly criteria?: ResourceCriteria

    /**
     * 
     * @type {Pageable}
     * @memberof ResourceV1ApiGetResources
     */
    readonly pageable?: Pageable
}

/**
 * Request parameters for updateResource operation in ResourceV1Api.
 * @export
 * @interface ResourceV1ApiUpdateResourceRequest
 */
export interface ResourceV1ApiUpdateResourceRequest {
    /**
     * 
     * @type {string}
     * @memberof ResourceV1ApiUpdateResource
     */
    readonly id: string

    /**
     * 
     * @type {UpdateResourceRequestDto}
     * @memberof ResourceV1ApiUpdateResource
     */
    readonly updateResourceRequestDto?: UpdateResourceRequestDto
}

/**
 * ResourceV1Api - object-oriented interface
 * @export
 * @class ResourceV1Api
 * @extends {BaseAPI}
 */
export class ResourceV1Api extends BaseAPI {
    /**
     * Create new resources
     * @param {ResourceV1ApiCreateResourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceV1Api
     */
    public createResource(requestParameters: ResourceV1ApiCreateResourceRequest, options?: RawAxiosRequestConfig) {
        return ResourceV1ApiFp(this.configuration).createResource(requestParameters.createResourceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a resource by ID
     * @param {ResourceV1ApiDeleteResourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceV1Api
     */
    public deleteResource(requestParameters: ResourceV1ApiDeleteResourceRequest, options?: RawAxiosRequestConfig) {
        return ResourceV1ApiFp(this.configuration).deleteResource(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete resources by list of ids
     * @param {ResourceV1ApiDeleteResourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceV1Api
     */
    public deleteResources(requestParameters: ResourceV1ApiDeleteResourcesRequest, options?: RawAxiosRequestConfig) {
        return ResourceV1ApiFp(this.configuration).deleteResources(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a resource by ID
     * @param {ResourceV1ApiGetResourceByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceV1Api
     */
    public getResourceById(requestParameters: ResourceV1ApiGetResourceByIdRequest, options?: RawAxiosRequestConfig) {
        return ResourceV1ApiFp(this.configuration).getResourceById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all resources
     * @param {ResourceV1ApiGetResourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceV1Api
     */
    public getResources(requestParameters: ResourceV1ApiGetResourcesRequest = {}, options?: RawAxiosRequestConfig) {
        return ResourceV1ApiFp(this.configuration).getResources(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing resource
     * @param {ResourceV1ApiUpdateResourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceV1Api
     */
    public updateResource(requestParameters: ResourceV1ApiUpdateResourceRequest, options?: RawAxiosRequestConfig) {
        return ResourceV1ApiFp(this.configuration).updateResource(requestParameters.id, requestParameters.updateResourceRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagV1Api - axios parameter creator
 * @export
 */
export const TagV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateTagRequestDto} createTagRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag: async (createTagRequestDto: CreateTagRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTagRequestDto' is not null or undefined
            assertParamExists('createTag', 'createTagRequestDto', createTagRequestDto)
            const localVarPath = `/api/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTagRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [tagIds] 
         * @param {Array<string>} [tagDetailIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (tagIds?: Array<string>, tagDetailIds?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (tagIds) {
                localVarQueryParameter['tagIds'] = tagIds;
            }

            if (tagDetailIds) {
                localVarQueryParameter['tagDetailIds'] = tagDetailIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [parentTag] 
         * @param {TagType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (parentTag?: Array<string>, type?: TagType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (parentTag) {
                localVarQueryParameter['parentTag'] = parentTag;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagV1Api - functional programming interface
 * @export
 */
export const TagV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateTagRequestDto} createTagRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTag(createTagRequestDto: CreateTagRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTag(createTagRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagV1Api.createTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Array<string>} [tagIds] 
         * @param {Array<string>} [tagDetailIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(tagIds?: Array<string>, tagDetailIds?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(tagIds, tagDetailIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagV1Api.deleteTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Array<string>} [parentTag] 
         * @param {TagType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(parentTag?: Array<string>, type?: TagType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(parentTag, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagV1Api.getTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagV1Api - factory interface
 * @export
 */
export const TagV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagV1ApiFp(configuration)
    return {
        /**
         * 
         * @param {TagV1ApiCreateTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(requestParameters: TagV1ApiCreateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createTag(requestParameters.createTagRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TagV1ApiDeleteTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(requestParameters: TagV1ApiDeleteTagRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTag(requestParameters.tagIds, requestParameters.tagDetailIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TagV1ApiGetTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(requestParameters: TagV1ApiGetTagsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<TagResponseDto>> {
            return localVarFp.getTags(requestParameters.parentTag, requestParameters.type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTag operation in TagV1Api.
 * @export
 * @interface TagV1ApiCreateTagRequest
 */
export interface TagV1ApiCreateTagRequest {
    /**
     * 
     * @type {CreateTagRequestDto}
     * @memberof TagV1ApiCreateTag
     */
    readonly createTagRequestDto: CreateTagRequestDto
}

/**
 * Request parameters for deleteTag operation in TagV1Api.
 * @export
 * @interface TagV1ApiDeleteTagRequest
 */
export interface TagV1ApiDeleteTagRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof TagV1ApiDeleteTag
     */
    readonly tagIds?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof TagV1ApiDeleteTag
     */
    readonly tagDetailIds?: Array<string>
}

/**
 * Request parameters for getTags operation in TagV1Api.
 * @export
 * @interface TagV1ApiGetTagsRequest
 */
export interface TagV1ApiGetTagsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof TagV1ApiGetTags
     */
    readonly parentTag?: Array<string>

    /**
     * 
     * @type {TagType}
     * @memberof TagV1ApiGetTags
     */
    readonly type?: TagType
}

/**
 * TagV1Api - object-oriented interface
 * @export
 * @class TagV1Api
 * @extends {BaseAPI}
 */
export class TagV1Api extends BaseAPI {
    /**
     * 
     * @param {TagV1ApiCreateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagV1Api
     */
    public createTag(requestParameters: TagV1ApiCreateTagRequest, options?: RawAxiosRequestConfig) {
        return TagV1ApiFp(this.configuration).createTag(requestParameters.createTagRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TagV1ApiDeleteTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagV1Api
     */
    public deleteTag(requestParameters: TagV1ApiDeleteTagRequest = {}, options?: RawAxiosRequestConfig) {
        return TagV1ApiFp(this.configuration).deleteTag(requestParameters.tagIds, requestParameters.tagDetailIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TagV1ApiGetTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagV1Api
     */
    public getTags(requestParameters: TagV1ApiGetTagsRequest = {}, options?: RawAxiosRequestConfig) {
        return TagV1ApiFp(this.configuration).getTags(requestParameters.parentTag, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TestV1Api - axios parameter creator
 * @export
 */
export const TestV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an entrance Test for a Course.
         * @param {CreateTestRequestDto} test 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTest: async (test: CreateTestRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'test' is not null or undefined
            assertParamExists('createTest', 'test', test)
            const localVarPath = `/api/v1/tests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (test !== undefined) { 
                localVarFormParams.append('test', new Blob([JSON.stringify(test)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Test of the Course.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTest: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTest', 'id', id)
            const localVarPath = `/api/v1/tests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an entrace Test for a Course.
         * @param {string} courseId The ID of the Course to fetch Test corresponding.
         * @param {string} type The type of the Test to be fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestByCourseIdAndType: async (courseId: string, type: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getTestByCourseIdAndType', 'courseId', courseId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getTestByCourseIdAndType', 'type', type)
            const localVarPath = `/api/v1/tests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (courseId !== undefined) {
                localVarQueryParameter['courseId'] = courseId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing entrance Test of a Course.
         * @param {string} id 
         * @param {UpdateTestRequestDto} test 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTest: async (id: string, test: UpdateTestRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTest', 'id', id)
            // verify required parameter 'test' is not null or undefined
            assertParamExists('updateTest', 'test', test)
            const localVarPath = `/api/v1/tests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (test !== undefined) { 
                localVarFormParams.append('test', new Blob([JSON.stringify(test)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestV1Api - functional programming interface
 * @export
 */
export const TestV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an entrance Test for a Course.
         * @param {CreateTestRequestDto} test 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTest(test: CreateTestRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdWrapperDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTest(test, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestV1Api.createTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a Test of the Course.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTest(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTest(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestV1Api.deleteTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an entrace Test for a Course.
         * @param {string} courseId The ID of the Course to fetch Test corresponding.
         * @param {string} type The type of the Test to be fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestByCourseIdAndType(courseId: string, type: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailTestOfTheCourseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestByCourseIdAndType(courseId, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestV1Api.getTestByCourseIdAndType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing entrance Test of a Course.
         * @param {string} id 
         * @param {UpdateTestRequestDto} test 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTest(id: string, test: UpdateTestRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailTestOfTheCourseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTest(id, test, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestV1Api.updateTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TestV1Api - factory interface
 * @export
 */
export const TestV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestV1ApiFp(configuration)
    return {
        /**
         * Create an entrance Test for a Course.
         * @param {TestV1ApiCreateTestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTest(requestParameters: TestV1ApiCreateTestRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdWrapperDto> {
            return localVarFp.createTest(requestParameters.test, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Test of the Course.
         * @param {TestV1ApiDeleteTestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTest(requestParameters: TestV1ApiDeleteTestRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTest(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an entrace Test for a Course.
         * @param {TestV1ApiGetTestByCourseIdAndTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestByCourseIdAndType(requestParameters: TestV1ApiGetTestByCourseIdAndTypeRequest, options?: RawAxiosRequestConfig): AxiosPromise<DetailTestOfTheCourseDto> {
            return localVarFp.getTestByCourseIdAndType(requestParameters.courseId, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing entrance Test of a Course.
         * @param {TestV1ApiUpdateTestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTest(requestParameters: TestV1ApiUpdateTestRequest, options?: RawAxiosRequestConfig): AxiosPromise<DetailTestOfTheCourseDto> {
            return localVarFp.updateTest(requestParameters.id, requestParameters.test, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTest operation in TestV1Api.
 * @export
 * @interface TestV1ApiCreateTestRequest
 */
export interface TestV1ApiCreateTestRequest {
    /**
     * 
     * @type {CreateTestRequestDto}
     * @memberof TestV1ApiCreateTest
     */
    readonly test: CreateTestRequestDto
}

/**
 * Request parameters for deleteTest operation in TestV1Api.
 * @export
 * @interface TestV1ApiDeleteTestRequest
 */
export interface TestV1ApiDeleteTestRequest {
    /**
     * 
     * @type {string}
     * @memberof TestV1ApiDeleteTest
     */
    readonly id: string
}

/**
 * Request parameters for getTestByCourseIdAndType operation in TestV1Api.
 * @export
 * @interface TestV1ApiGetTestByCourseIdAndTypeRequest
 */
export interface TestV1ApiGetTestByCourseIdAndTypeRequest {
    /**
     * The ID of the Course to fetch Test corresponding.
     * @type {string}
     * @memberof TestV1ApiGetTestByCourseIdAndType
     */
    readonly courseId: string

    /**
     * The type of the Test to be fetch.
     * @type {string}
     * @memberof TestV1ApiGetTestByCourseIdAndType
     */
    readonly type: string
}

/**
 * Request parameters for updateTest operation in TestV1Api.
 * @export
 * @interface TestV1ApiUpdateTestRequest
 */
export interface TestV1ApiUpdateTestRequest {
    /**
     * 
     * @type {string}
     * @memberof TestV1ApiUpdateTest
     */
    readonly id: string

    /**
     * 
     * @type {UpdateTestRequestDto}
     * @memberof TestV1ApiUpdateTest
     */
    readonly test: UpdateTestRequestDto
}

/**
 * TestV1Api - object-oriented interface
 * @export
 * @class TestV1Api
 * @extends {BaseAPI}
 */
export class TestV1Api extends BaseAPI {
    /**
     * Create an entrance Test for a Course.
     * @param {TestV1ApiCreateTestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestV1Api
     */
    public createTest(requestParameters: TestV1ApiCreateTestRequest, options?: RawAxiosRequestConfig) {
        return TestV1ApiFp(this.configuration).createTest(requestParameters.test, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Test of the Course.
     * @param {TestV1ApiDeleteTestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestV1Api
     */
    public deleteTest(requestParameters: TestV1ApiDeleteTestRequest, options?: RawAxiosRequestConfig) {
        return TestV1ApiFp(this.configuration).deleteTest(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an entrace Test for a Course.
     * @param {TestV1ApiGetTestByCourseIdAndTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestV1Api
     */
    public getTestByCourseIdAndType(requestParameters: TestV1ApiGetTestByCourseIdAndTypeRequest, options?: RawAxiosRequestConfig) {
        return TestV1ApiFp(this.configuration).getTestByCourseIdAndType(requestParameters.courseId, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing entrance Test of a Course.
     * @param {TestV1ApiUpdateTestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestV1Api
     */
    public updateTest(requestParameters: TestV1ApiUpdateTestRequest, options?: RawAxiosRequestConfig) {
        return TestV1ApiFp(this.configuration).updateTest(requestParameters.id, requestParameters.test, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserResourceHistoryV1Api - axios parameter creator
 * @export
 */
export const UserResourceHistoryV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a resource accessed by the user
         * @param {string} userInfoId userInfoId of a user.
         * @param {string} resourceId resourceId of a resource.
         * @param {UserResourceType} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserResource: async (userInfoId: string, resourceId: string, type: UserResourceType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userInfoId' is not null or undefined
            assertParamExists('createUserResource', 'userInfoId', userInfoId)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('createUserResource', 'resourceId', resourceId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createUserResource', 'type', type)
            const localVarPath = `/api/v1/user/resources-accessed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (userInfoId !== undefined) { 
                localVarFormParams.append('userInfoId', userInfoId as any);
            }
    
            if (resourceId !== undefined) { 
                localVarFormParams.append('resourceId', resourceId as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.append('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of resources accessed by the user using userInfoId and type.
         * @param {UserResourceHistoryCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcesAccessedByUserInfoIdAndType: async (criteria?: UserResourceHistoryCriteria, pageable?: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/resources-accessed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (criteria !== undefined) {
                for (const [key, value] of Object.entries(criteria)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserResourceHistoryV1Api - functional programming interface
 * @export
 */
export const UserResourceHistoryV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserResourceHistoryV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a resource accessed by the user
         * @param {string} userInfoId userInfoId of a user.
         * @param {string} resourceId resourceId of a resource.
         * @param {UserResourceType} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserResource(userInfoId: string, resourceId: string, type: UserResourceType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdWrapperDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserResource(userInfoId, resourceId, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserResourceHistoryV1Api.createUserResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the list of resources accessed by the user using userInfoId and type.
         * @param {UserResourceHistoryCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourcesAccessedByUserInfoIdAndType(criteria?: UserResourceHistoryCriteria, pageable?: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResourcesAccessedResponsePaginatedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourcesAccessedByUserInfoIdAndType(criteria, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserResourceHistoryV1Api.getResourcesAccessedByUserInfoIdAndType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserResourceHistoryV1Api - factory interface
 * @export
 */
export const UserResourceHistoryV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserResourceHistoryV1ApiFp(configuration)
    return {
        /**
         * Create a resource accessed by the user
         * @param {UserResourceHistoryV1ApiCreateUserResourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserResource(requestParameters: UserResourceHistoryV1ApiCreateUserResourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdWrapperDto> {
            return localVarFp.createUserResource(requestParameters.userInfoId, requestParameters.resourceId, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of resources accessed by the user using userInfoId and type.
         * @param {UserResourceHistoryV1ApiGetResourcesAccessedByUserInfoIdAndTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcesAccessedByUserInfoIdAndType(requestParameters: UserResourceHistoryV1ApiGetResourcesAccessedByUserInfoIdAndTypeRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<UserResourcesAccessedResponsePaginatedDto> {
            return localVarFp.getResourcesAccessedByUserInfoIdAndType(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createUserResource operation in UserResourceHistoryV1Api.
 * @export
 * @interface UserResourceHistoryV1ApiCreateUserResourceRequest
 */
export interface UserResourceHistoryV1ApiCreateUserResourceRequest {
    /**
     * userInfoId of a user.
     * @type {string}
     * @memberof UserResourceHistoryV1ApiCreateUserResource
     */
    readonly userInfoId: string

    /**
     * resourceId of a resource.
     * @type {string}
     * @memberof UserResourceHistoryV1ApiCreateUserResource
     */
    readonly resourceId: string

    /**
     * 
     * @type {UserResourceType}
     * @memberof UserResourceHistoryV1ApiCreateUserResource
     */
    readonly type: UserResourceType
}

/**
 * Request parameters for getResourcesAccessedByUserInfoIdAndType operation in UserResourceHistoryV1Api.
 * @export
 * @interface UserResourceHistoryV1ApiGetResourcesAccessedByUserInfoIdAndTypeRequest
 */
export interface UserResourceHistoryV1ApiGetResourcesAccessedByUserInfoIdAndTypeRequest {
    /**
     * 
     * @type {UserResourceHistoryCriteria}
     * @memberof UserResourceHistoryV1ApiGetResourcesAccessedByUserInfoIdAndType
     */
    readonly criteria?: UserResourceHistoryCriteria

    /**
     * 
     * @type {Pageable}
     * @memberof UserResourceHistoryV1ApiGetResourcesAccessedByUserInfoIdAndType
     */
    readonly pageable?: Pageable
}

/**
 * UserResourceHistoryV1Api - object-oriented interface
 * @export
 * @class UserResourceHistoryV1Api
 * @extends {BaseAPI}
 */
export class UserResourceHistoryV1Api extends BaseAPI {
    /**
     * Create a resource accessed by the user
     * @param {UserResourceHistoryV1ApiCreateUserResourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserResourceHistoryV1Api
     */
    public createUserResource(requestParameters: UserResourceHistoryV1ApiCreateUserResourceRequest, options?: RawAxiosRequestConfig) {
        return UserResourceHistoryV1ApiFp(this.configuration).createUserResource(requestParameters.userInfoId, requestParameters.resourceId, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list of resources accessed by the user using userInfoId and type.
     * @param {UserResourceHistoryV1ApiGetResourcesAccessedByUserInfoIdAndTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserResourceHistoryV1Api
     */
    public getResourcesAccessedByUserInfoIdAndType(requestParameters: UserResourceHistoryV1ApiGetResourcesAccessedByUserInfoIdAndTypeRequest = {}, options?: RawAxiosRequestConfig) {
        return UserResourceHistoryV1ApiFp(this.configuration).getResourcesAccessedByUserInfoIdAndType(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserResourceV1Api - axios parameter creator
 * @export
 */
export const UserResourceV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get resource by ID for page user.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserResourceById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserResourceById', 'id', id)
            const localVarPath = `/api/v1/user/resources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list resources for page user.
         * @param {ResourceCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserResources: async (criteria?: ResourceCriteria, pageable?: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (criteria !== undefined) {
                for (const [key, value] of Object.entries(criteria)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserResourceV1Api - functional programming interface
 * @export
 */
export const UserResourceV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserResourceV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Get resource by ID for page user.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserResourceById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResourceDetailResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserResourceById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserResourceV1Api.getUserResourceById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list resources for page user.
         * @param {ResourceCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserResources(criteria?: ResourceCriteria, pageable?: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResourceResponsePaginatedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserResources(criteria, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserResourceV1Api.getUserResources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserResourceV1Api - factory interface
 * @export
 */
export const UserResourceV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserResourceV1ApiFp(configuration)
    return {
        /**
         * Get resource by ID for page user.
         * @param {UserResourceV1ApiGetUserResourceByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserResourceById(requestParameters: UserResourceV1ApiGetUserResourceByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserResourceDetailResponseDto> {
            return localVarFp.getUserResourceById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list resources for page user.
         * @param {UserResourceV1ApiGetUserResourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserResources(requestParameters: UserResourceV1ApiGetUserResourcesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<UserResourceResponsePaginatedDto> {
            return localVarFp.getUserResources(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getUserResourceById operation in UserResourceV1Api.
 * @export
 * @interface UserResourceV1ApiGetUserResourceByIdRequest
 */
export interface UserResourceV1ApiGetUserResourceByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof UserResourceV1ApiGetUserResourceById
     */
    readonly id: string
}

/**
 * Request parameters for getUserResources operation in UserResourceV1Api.
 * @export
 * @interface UserResourceV1ApiGetUserResourcesRequest
 */
export interface UserResourceV1ApiGetUserResourcesRequest {
    /**
     * 
     * @type {ResourceCriteria}
     * @memberof UserResourceV1ApiGetUserResources
     */
    readonly criteria?: ResourceCriteria

    /**
     * 
     * @type {Pageable}
     * @memberof UserResourceV1ApiGetUserResources
     */
    readonly pageable?: Pageable
}

/**
 * UserResourceV1Api - object-oriented interface
 * @export
 * @class UserResourceV1Api
 * @extends {BaseAPI}
 */
export class UserResourceV1Api extends BaseAPI {
    /**
     * Get resource by ID for page user.
     * @param {UserResourceV1ApiGetUserResourceByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserResourceV1Api
     */
    public getUserResourceById(requestParameters: UserResourceV1ApiGetUserResourceByIdRequest, options?: RawAxiosRequestConfig) {
        return UserResourceV1ApiFp(this.configuration).getUserResourceById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list resources for page user.
     * @param {UserResourceV1ApiGetUserResourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserResourceV1Api
     */
    public getUserResources(requestParameters: UserResourceV1ApiGetUserResourcesRequest = {}, options?: RawAxiosRequestConfig) {
        return UserResourceV1ApiFp(this.configuration).getUserResources(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserV1Api - axios parameter creator
 * @export
 */
export const UserV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new user
         * @param {CreateUserRequestDto} user 
         * @param {File} [avatar] Profile image
         * @param {Array<File>} [certificate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (user: CreateUserRequestDto, avatar?: File, certificate?: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createUser', 'user', user)
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (user !== undefined) { 
                localVarFormParams.append('user', new Blob([JSON.stringify(user)], { type: "application/json", }));
            }
    
            if (avatar !== undefined) { 
                localVarFormParams.append('avatar', avatar as any);
            }
                if (certificate) {
                certificate.forEach((element) => {
                    localVarFormParams.append('certificate', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an user by ID
         * @param {string} id 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, password: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('deleteUser', 'password', password)
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [userIds] 
         * @param {string} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsers: async (userIds?: Array<string>, password?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an user by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserById', 'id', id)
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get users by criteria
         * @param {UserInfoCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (criteria?: UserInfoCriteria, pageable?: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (criteria !== undefined) {
                for (const [key, value] of Object.entries(criteria)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a new user
         * @param {InviteUserRequestDto} inviteUserRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUser: async (inviteUserRequestDto: InviteUserRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteUserRequestDto' is not null or undefined
            assertParamExists('inviteUser', 'inviteUserRequestDto', inviteUserRequestDto)
            const localVarPath = `/api/v1/users/invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteUserRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing user
         * @param {string} id 
         * @param {UpdateUserRequestDto} [user] 
         * @param {File} [avatar] Profile image
         * @param {Array<string>} [deleteCertificatePaths] 
         * @param {Array<File>} [newCertificates] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: string, user?: UpdateUserRequestDto, avatar?: File, deleteCertificatePaths?: Array<string>, newCertificates?: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (user !== undefined) { 
                localVarFormParams.append('user', new Blob([JSON.stringify(user)], { type: "application/json", }));
            }
    
            if (avatar !== undefined) { 
                localVarFormParams.append('avatar', avatar as any);
            }
                if (deleteCertificatePaths) {
                localVarFormParams.append('deleteCertificatePaths', deleteCertificatePaths.join(COLLECTION_FORMATS.csv));
            }

                if (newCertificates) {
                newCertificates.forEach((element) => {
                    localVarFormParams.append('newCertificates', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserV1Api - functional programming interface
 * @export
 */
export const UserV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new user
         * @param {CreateUserRequestDto} user 
         * @param {File} [avatar] Profile image
         * @param {Array<File>} [certificate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(user: CreateUserRequestDto, avatar?: File, certificate?: Array<File>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdWrapperDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(user, avatar, certificate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserV1Api.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an user by ID
         * @param {string} id 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, password: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, password, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserV1Api.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Array<string>} [userIds] 
         * @param {string} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsers(userIds?: Array<string>, password?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUsers(userIds, password, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserV1Api.deleteUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUserInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUserInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserV1Api.getCurrentUserInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an user by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserV1Api.getUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get users by criteria
         * @param {UserInfoCriteria} [criteria] 
         * @param {Pageable} [pageable] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(criteria?: UserInfoCriteria, pageable?: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponsePaginatedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(criteria, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserV1Api.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invite a new user
         * @param {InviteUserRequestDto} inviteUserRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteUser(inviteUserRequestDto: InviteUserRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdWrapperDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteUser(inviteUserRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserV1Api.inviteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing user
         * @param {string} id 
         * @param {UpdateUserRequestDto} [user] 
         * @param {File} [avatar] Profile image
         * @param {Array<string>} [deleteCertificatePaths] 
         * @param {Array<File>} [newCertificates] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: string, user?: UpdateUserRequestDto, avatar?: File, deleteCertificatePaths?: Array<string>, newCertificates?: Array<File>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, user, avatar, deleteCertificatePaths, newCertificates, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserV1Api.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserV1Api - factory interface
 * @export
 */
export const UserV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserV1ApiFp(configuration)
    return {
        /**
         * Create a new user
         * @param {UserV1ApiCreateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(requestParameters: UserV1ApiCreateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdWrapperDto> {
            return localVarFp.createUser(requestParameters.user, requestParameters.avatar, requestParameters.certificate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an user by ID
         * @param {UserV1ApiDeleteUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(requestParameters: UserV1ApiDeleteUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(requestParameters.id, requestParameters.password, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserV1ApiDeleteUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsers(requestParameters: UserV1ApiDeleteUsersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUsers(requestParameters.userIds, requestParameters.password, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserInfo(options?: RawAxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.getCurrentUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Get an user by ID
         * @param {UserV1ApiGetUserByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(requestParameters: UserV1ApiGetUserByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.getUserById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get users by criteria
         * @param {UserV1ApiGetUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(requestParameters: UserV1ApiGetUsersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<UserResponsePaginatedDto> {
            return localVarFp.getUsers(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a new user
         * @param {UserV1ApiInviteUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUser(requestParameters: UserV1ApiInviteUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdWrapperDto> {
            return localVarFp.inviteUser(requestParameters.inviteUserRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing user
         * @param {UserV1ApiUpdateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestParameters: UserV1ApiUpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateUser(requestParameters.id, requestParameters.user, requestParameters.avatar, requestParameters.deleteCertificatePaths, requestParameters.newCertificates, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createUser operation in UserV1Api.
 * @export
 * @interface UserV1ApiCreateUserRequest
 */
export interface UserV1ApiCreateUserRequest {
    /**
     * 
     * @type {CreateUserRequestDto}
     * @memberof UserV1ApiCreateUser
     */
    readonly user: CreateUserRequestDto

    /**
     * Profile image
     * @type {File}
     * @memberof UserV1ApiCreateUser
     */
    readonly avatar?: File

    /**
     * 
     * @type {Array<File>}
     * @memberof UserV1ApiCreateUser
     */
    readonly certificate?: Array<File>
}

/**
 * Request parameters for deleteUser operation in UserV1Api.
 * @export
 * @interface UserV1ApiDeleteUserRequest
 */
export interface UserV1ApiDeleteUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserV1ApiDeleteUser
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof UserV1ApiDeleteUser
     */
    readonly password: string
}

/**
 * Request parameters for deleteUsers operation in UserV1Api.
 * @export
 * @interface UserV1ApiDeleteUsersRequest
 */
export interface UserV1ApiDeleteUsersRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof UserV1ApiDeleteUsers
     */
    readonly userIds?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof UserV1ApiDeleteUsers
     */
    readonly password?: string
}

/**
 * Request parameters for getUserById operation in UserV1Api.
 * @export
 * @interface UserV1ApiGetUserByIdRequest
 */
export interface UserV1ApiGetUserByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof UserV1ApiGetUserById
     */
    readonly id: string
}

/**
 * Request parameters for getUsers operation in UserV1Api.
 * @export
 * @interface UserV1ApiGetUsersRequest
 */
export interface UserV1ApiGetUsersRequest {
    /**
     * 
     * @type {UserInfoCriteria}
     * @memberof UserV1ApiGetUsers
     */
    readonly criteria?: UserInfoCriteria

    /**
     * 
     * @type {Pageable}
     * @memberof UserV1ApiGetUsers
     */
    readonly pageable?: Pageable
}

/**
 * Request parameters for inviteUser operation in UserV1Api.
 * @export
 * @interface UserV1ApiInviteUserRequest
 */
export interface UserV1ApiInviteUserRequest {
    /**
     * 
     * @type {InviteUserRequestDto}
     * @memberof UserV1ApiInviteUser
     */
    readonly inviteUserRequestDto: InviteUserRequestDto
}

/**
 * Request parameters for updateUser operation in UserV1Api.
 * @export
 * @interface UserV1ApiUpdateUserRequest
 */
export interface UserV1ApiUpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserV1ApiUpdateUser
     */
    readonly id: string

    /**
     * 
     * @type {UpdateUserRequestDto}
     * @memberof UserV1ApiUpdateUser
     */
    readonly user?: UpdateUserRequestDto

    /**
     * Profile image
     * @type {File}
     * @memberof UserV1ApiUpdateUser
     */
    readonly avatar?: File

    /**
     * 
     * @type {Array<string>}
     * @memberof UserV1ApiUpdateUser
     */
    readonly deleteCertificatePaths?: Array<string>

    /**
     * 
     * @type {Array<File>}
     * @memberof UserV1ApiUpdateUser
     */
    readonly newCertificates?: Array<File>
}

/**
 * UserV1Api - object-oriented interface
 * @export
 * @class UserV1Api
 * @extends {BaseAPI}
 */
export class UserV1Api extends BaseAPI {
    /**
     * Create a new user
     * @param {UserV1ApiCreateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserV1Api
     */
    public createUser(requestParameters: UserV1ApiCreateUserRequest, options?: RawAxiosRequestConfig) {
        return UserV1ApiFp(this.configuration).createUser(requestParameters.user, requestParameters.avatar, requestParameters.certificate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an user by ID
     * @param {UserV1ApiDeleteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserV1Api
     */
    public deleteUser(requestParameters: UserV1ApiDeleteUserRequest, options?: RawAxiosRequestConfig) {
        return UserV1ApiFp(this.configuration).deleteUser(requestParameters.id, requestParameters.password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserV1ApiDeleteUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserV1Api
     */
    public deleteUsers(requestParameters: UserV1ApiDeleteUsersRequest = {}, options?: RawAxiosRequestConfig) {
        return UserV1ApiFp(this.configuration).deleteUsers(requestParameters.userIds, requestParameters.password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserV1Api
     */
    public getCurrentUserInfo(options?: RawAxiosRequestConfig) {
        return UserV1ApiFp(this.configuration).getCurrentUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an user by ID
     * @param {UserV1ApiGetUserByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserV1Api
     */
    public getUserById(requestParameters: UserV1ApiGetUserByIdRequest, options?: RawAxiosRequestConfig) {
        return UserV1ApiFp(this.configuration).getUserById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get users by criteria
     * @param {UserV1ApiGetUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserV1Api
     */
    public getUsers(requestParameters: UserV1ApiGetUsersRequest = {}, options?: RawAxiosRequestConfig) {
        return UserV1ApiFp(this.configuration).getUsers(requestParameters.criteria, requestParameters.pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a new user
     * @param {UserV1ApiInviteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserV1Api
     */
    public inviteUser(requestParameters: UserV1ApiInviteUserRequest, options?: RawAxiosRequestConfig) {
        return UserV1ApiFp(this.configuration).inviteUser(requestParameters.inviteUserRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing user
     * @param {UserV1ApiUpdateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserV1Api
     */
    public updateUser(requestParameters: UserV1ApiUpdateUserRequest, options?: RawAxiosRequestConfig) {
        return UserV1ApiFp(this.configuration).updateUser(requestParameters.id, requestParameters.user, requestParameters.avatar, requestParameters.deleteCertificatePaths, requestParameters.newCertificates, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhookV1Api - axios parameter creator
 * @export
 */
export const WebhookV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Receive a keycloak webhook
         * @param {WebhookKeycloakRequestDto} webhookKeycloakRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeKeycloakEvent: async (webhookKeycloakRequestDto: WebhookKeycloakRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookKeycloakRequestDto' is not null or undefined
            assertParamExists('subscribeKeycloakEvent', 'webhookKeycloakRequestDto', webhookKeycloakRequestDto)
            const localVarPath = `/api/v1/webhooks/keycloak`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookKeycloakRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Receive notifications from MinIO webhook
         * @param {WebhookMinIOEventDto} webhookMinIOEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeMinioEvent: async (webhookMinIOEventDto: WebhookMinIOEventDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookMinIOEventDto' is not null or undefined
            assertParamExists('subscribeMinioEvent', 'webhookMinIOEventDto', webhookMinIOEventDto)
            const localVarPath = `/api/v1/webhooks/minio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookMinIOEventDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookV1Api - functional programming interface
 * @export
 */
export const WebhookV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Receive a keycloak webhook
         * @param {WebhookKeycloakRequestDto} webhookKeycloakRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribeKeycloakEvent(webhookKeycloakRequestDto: WebhookKeycloakRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribeKeycloakEvent(webhookKeycloakRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookV1Api.subscribeKeycloakEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Receive notifications from MinIO webhook
         * @param {WebhookMinIOEventDto} webhookMinIOEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribeMinioEvent(webhookMinIOEventDto: WebhookMinIOEventDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribeMinioEvent(webhookMinIOEventDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookV1Api.subscribeMinioEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhookV1Api - factory interface
 * @export
 */
export const WebhookV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookV1ApiFp(configuration)
    return {
        /**
         * 
         * @summary Receive a keycloak webhook
         * @param {WebhookV1ApiSubscribeKeycloakEventRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeKeycloakEvent(requestParameters: WebhookV1ApiSubscribeKeycloakEventRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.subscribeKeycloakEvent(requestParameters.webhookKeycloakRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Receive notifications from MinIO webhook
         * @param {WebhookV1ApiSubscribeMinioEventRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeMinioEvent(requestParameters: WebhookV1ApiSubscribeMinioEventRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.subscribeMinioEvent(requestParameters.webhookMinIOEventDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for subscribeKeycloakEvent operation in WebhookV1Api.
 * @export
 * @interface WebhookV1ApiSubscribeKeycloakEventRequest
 */
export interface WebhookV1ApiSubscribeKeycloakEventRequest {
    /**
     * 
     * @type {WebhookKeycloakRequestDto}
     * @memberof WebhookV1ApiSubscribeKeycloakEvent
     */
    readonly webhookKeycloakRequestDto: WebhookKeycloakRequestDto
}

/**
 * Request parameters for subscribeMinioEvent operation in WebhookV1Api.
 * @export
 * @interface WebhookV1ApiSubscribeMinioEventRequest
 */
export interface WebhookV1ApiSubscribeMinioEventRequest {
    /**
     * 
     * @type {WebhookMinIOEventDto}
     * @memberof WebhookV1ApiSubscribeMinioEvent
     */
    readonly webhookMinIOEventDto: WebhookMinIOEventDto
}

/**
 * WebhookV1Api - object-oriented interface
 * @export
 * @class WebhookV1Api
 * @extends {BaseAPI}
 */
export class WebhookV1Api extends BaseAPI {
    /**
     * 
     * @summary Receive a keycloak webhook
     * @param {WebhookV1ApiSubscribeKeycloakEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookV1Api
     */
    public subscribeKeycloakEvent(requestParameters: WebhookV1ApiSubscribeKeycloakEventRequest, options?: RawAxiosRequestConfig) {
        return WebhookV1ApiFp(this.configuration).subscribeKeycloakEvent(requestParameters.webhookKeycloakRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Receive notifications from MinIO webhook
     * @param {WebhookV1ApiSubscribeMinioEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookV1Api
     */
    public subscribeMinioEvent(requestParameters: WebhookV1ApiSubscribeMinioEventRequest, options?: RawAxiosRequestConfig) {
        return WebhookV1ApiFp(this.configuration).subscribeMinioEvent(requestParameters.webhookMinIOEventDto, options).then((request) => request(this.axios, this.basePath));
    }
}



